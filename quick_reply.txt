Directory Structure:

└── ./
    ├── api
    │   └── QuickReplyApi.js
    ├── html
    │   ├── qrEditor.html
    │   └── settings.html
    ├── lib
    │   └── morphdom-esm.js
    ├── src
    │   ├── ui
    │   │   ├── ctx
    │   │   │   ├── ContextMenu.js
    │   │   │   ├── MenuHeader.js
    │   │   │   ├── MenuItem.js
    │   │   │   └── SubMenu.js
    │   │   ├── ButtonUi.js
    │   │   └── SettingsUi.js
    │   ├── AutoExecuteHandler.js
    │   ├── QuickReply.js
    │   ├── QuickReplyConfig.js
    │   ├── QuickReplyContextLink.js
    │   ├── QuickReplySet.js
    │   ├── QuickReplySetLink.js
    │   ├── QuickReplySettings.js
    │   └── SlashCommandHandler.js
    ├── index.js
    ├── manifest.json
    ├── style.css
    └── style.less



---
File: /api/QuickReplyApi.js
---

// eslint-disable-next-line no-unused-vars
import { QuickReply } from '../src/QuickReply.js';
import { QuickReplyContextLink } from '../src/QuickReplyContextLink.js';
import { QuickReplySet } from '../src/QuickReplySet.js';
// eslint-disable-next-line no-unused-vars
import { QuickReplySettings } from '../src/QuickReplySettings.js';
// eslint-disable-next-line no-unused-vars
import { SettingsUi } from '../src/ui/SettingsUi.js';
import { onlyUnique } from '../../../utils.js';

export class QuickReplyApi {
    /**@type {QuickReplySettings}*/ settings;
    /**@type {SettingsUi}*/ settingsUi;




    constructor(/**@type {QuickReplySettings}*/settings, /**@type {SettingsUi}*/settingsUi) {
        this.settings = settings;
        this.settingsUi = settingsUi;
    }




    /**
     * @param {QuickReply} qr
     * @returns {QuickReplySet}
     */
    getSetByQr(qr) {
        return QuickReplySet.list.find(it=>it.qrList.includes(qr));
    }

    /**
     * Finds and returns an existing Quick Reply Set by its name.
     *
     * @param {string} name name of the quick reply set
     * @returns the quick reply set, or undefined if not found
     */
    getSetByName(name) {
        return QuickReplySet.get(name);
    }

    /**
     * Finds and returns an existing Quick Reply by its set's name and its label.
     *
     * @param {string} setName name of the quick reply set
     * @param {string|number} label label or numeric ID of the quick reply
     * @returns the quick reply, or undefined if not found
     */
    getQrByLabel(setName, label) {
        const set = this.getSetByName(setName);
        if (!set) return;
        if (Number.isInteger(label)) return set.qrList.find(it=>it.id == label);
        return set.qrList.find(it=>it.label == label);
    }




    /**
     * Executes a quick reply by its index and returns the result.
     *
     * @param {Number} idx the index (zero-based) of the quick reply to execute
     * @returns the return value of the quick reply, or undefined if not found
     */
    async executeQuickReplyByIndex(idx) {
        const qr = [...this.settings.config.setList, ...(this.settings.chatConfig?.setList ?? [])]
            .map(it=>it.set.qrList)
            .flat()[idx]
        ;
        if (qr) {
            return await qr.onExecute();
        } else {
            throw new Error(`No quick reply at index "${idx}"`);
        }
    }

    /**
     * Executes an existing quick reply.
     *
     * @param {string} setName name of the existing quick reply set
     * @param {string|number} label label of the existing quick reply (text on the button) or its numeric ID
     * @param {object} [args] optional arguments
     * @param {import('../../../slash-commands.js').ExecuteSlashCommandsOptions} [options] optional execution options
     */
    async executeQuickReply(setName, label, args = {}, options = {}) {
        const qr = this.getQrByLabel(setName, label);
        if (!qr) {
            throw new Error(`No quick reply with label "${label}" in set "${setName}" found.`);
        }
        return await qr.execute(args, false, false, options);
    }


    /**
     * Adds or removes a quick reply set to the list of globally active quick reply sets.
     *
     * @param {string} name the name of the set
     * @param {boolean} isVisible whether to show the set's buttons or not
     */
    toggleGlobalSet(name, isVisible = true) {
        const set = this.getSetByName(name);
        if (!set) {
            throw new Error(`No quick reply set with name "${name}" found.`);
        }
        if (this.settings.config.hasSet(set)) {
            this.settings.config.removeSet(set);
        } else {
            this.settings.config.addSet(set, isVisible);
        }
    }

    /**
     * Adds a quick reply set to the list of globally active quick reply sets.
     *
     * @param {string} name the name of the set
     * @param {boolean} isVisible whether to show the set's buttons or not
     */
    addGlobalSet(name, isVisible = true) {
        const set = this.getSetByName(name);
        if (!set) {
            throw new Error(`No quick reply set with name "${name}" found.`);
        }
        this.settings.config.addSet(set, isVisible);
    }

    /**
     * Removes a quick reply set from the list of globally active quick reply sets.
     *
     * @param {string} name the name of the set
     */
    removeGlobalSet(name) {
        const set = this.getSetByName(name);
        if (!set) {
            throw new Error(`No quick reply set with name "${name}" found.`);
        }
        this.settings.config.removeSet(set);
    }


    /**
     * Adds or removes a quick reply set to the list of the current chat's active quick reply sets.
     *
     * @param {string} name the name of the set
     * @param {boolean} isVisible whether to show the set's buttons or not
     */
    toggleChatSet(name, isVisible = true) {
        if (!this.settings.chatConfig) return;
        const set = this.getSetByName(name);
        if (!set) {
            throw new Error(`No quick reply set with name "${name}" found.`);
        }
        if (this.settings.chatConfig.hasSet(set)) {
            this.settings.chatConfig.removeSet(set);
        } else {
            this.settings.chatConfig.addSet(set, isVisible);
        }
    }

    /**
     * Adds a quick reply set to the list of the current chat's active quick reply sets.
     *
     * @param {string} name the name of the set
     * @param {boolean} isVisible whether to show the set's buttons or not
     */
    addChatSet(name, isVisible = true) {
        if (!this.settings.chatConfig) return;
        const set = this.getSetByName(name);
        if (!set) {
            throw new Error(`No quick reply set with name "${name}" found.`);
        }
        this.settings.chatConfig.addSet(set, isVisible);
    }

    /**
     * Removes a quick reply set from the list of the current chat's active quick reply sets.
     *
     * @param {string} name the name of the set
     */
    removeChatSet(name) {
        if (!this.settings.chatConfig) return;
        const set = this.getSetByName(name);
        if (!set) {
            throw new Error(`No quick reply set with name "${name}" found.`);
        }
        this.settings.chatConfig.removeSet(set);
    }


    /**
     * Creates a new quick reply in an existing quick reply set.
     *
     * @param {string} setName name of the quick reply set to insert the new quick reply into
     * @param {string} label label for the new quick reply (text on the button)
     * @param {object} [props]
     * @param {string} [props.icon] the icon to show on the QR button
     * @param {boolean} [props.showLabel] whether to show the label even when an icon is assigned
     * @param {string} [props.message] the message to be sent or slash command to be executed by the new quick reply
     * @param {string} [props.title] the title / tooltip to be shown on the quick reply button
     * @param {boolean} [props.isHidden] whether to hide or show the button
     * @param {boolean} [props.executeOnStartup] whether to execute the quick reply when SillyTavern starts
     * @param {boolean} [props.executeOnUser] whether to execute the quick reply after a user has sent a message
     * @param {boolean} [props.executeOnAi] whether to execute the quick reply after the AI has sent a message
     * @param {boolean} [props.executeOnChatChange] whether to execute the quick reply when a new chat is loaded
     * @param {boolean} [props.executeOnGroupMemberDraft] whether to execute the quick reply when a group member is selected
     * @param {boolean} [props.executeOnNewChat] whether to execute the quick reply when a new chat is created
     * @param {string} [props.automationId] when not empty, the quick reply will be executed when the WI with the given automation ID is activated
     * @returns {QuickReply} the new quick reply
     */
    createQuickReply(setName, label, {
        icon,
        showLabel,
        message,
        title,
        isHidden,
        executeOnStartup,
        executeOnUser,
        executeOnAi,
        executeOnChatChange,
        executeOnGroupMemberDraft,
        executeOnNewChat,
        automationId,
    } = {}) {
        const set = this.getSetByName(setName);
        if (!set) {
            throw new Error(`No quick reply set with named "${setName}" found.`);
        }
        const qr = set.addQuickReply();
        qr.label = label ?? '';
        qr.icon = icon ??  '';
        qr.showLabel = showLabel ?? false;
        qr.message = message ?? '';
        qr.title = title ?? '';
        qr.isHidden = isHidden ?? false;
        qr.executeOnStartup = executeOnStartup ?? false;
        qr.executeOnUser = executeOnUser ?? false;
        qr.executeOnAi = executeOnAi ?? false;
        qr.executeOnChatChange = executeOnChatChange ?? false;
        qr.executeOnGroupMemberDraft = executeOnGroupMemberDraft ?? false;
        qr.executeOnNewChat = executeOnNewChat ?? false;
        qr.automationId = automationId ?? '';
        qr.onUpdate();
        return qr;
    }

    /**
     * Updates an existing quick reply.
     *
     * @param {string} setName name of the existing quick reply set
     * @param {string|number} label label of the existing quick reply (text on the button) or its numeric ID
     * @param {object} [props]
     * @param {string} [props.icon] the icon to show on the QR button
     * @param {boolean} [props.showLabel] whether to show the label even when an icon is assigned
     * @param {string} [props.newLabel] new label for quick reply (text on the button)
     * @param {string} [props.message] the message to be sent or slash command to be executed by the quick reply
     * @param {string} [props.title] the title / tooltip to be shown on the quick reply button
     * @param {boolean} [props.isHidden] whether to hide or show the button
     * @param {boolean} [props.executeOnStartup] whether to execute the quick reply when SillyTavern starts
     * @param {boolean} [props.executeOnUser] whether to execute the quick reply after a user has sent a message
     * @param {boolean} [props.executeOnAi] whether to execute the quick reply after the AI has sent a message
     * @param {boolean} [props.executeOnChatChange] whether to execute the quick reply when a new chat is loaded
     * @param {boolean} [props.executeOnGroupMemberDraft] whether to execute the quick reply when a group member is selected
     * @param {boolean} [props.executeOnNewChat] whether to execute the quick reply when a new chat is created
     * @param {string} [props.automationId] when not empty, the quick reply will be executed when the WI with the given automation ID is activated
     * @returns {QuickReply} the altered quick reply
     */
    updateQuickReply(setName, label, {
        icon,
        showLabel,
        newLabel,
        message,
        title,
        isHidden,
        executeOnStartup,
        executeOnUser,
        executeOnAi,
        executeOnChatChange,
        executeOnGroupMemberDraft,
        executeOnNewChat,
        automationId,
    } = {}) {
        const qr = this.getQrByLabel(setName, label);
        if (!qr) {
            throw new Error(`No quick reply with label "${label}" in set "${setName}" found.`);
        }
        qr.updateIcon(icon ?? qr.icon);
        qr.updateShowLabel(showLabel ?? qr.showLabel);
        qr.updateLabel(newLabel ?? qr.label);
        qr.updateMessage(message ?? qr.message);
        qr.updateTitle(title ?? qr.title);
        qr.isHidden = isHidden ?? qr.isHidden;
        qr.executeOnStartup = executeOnStartup ?? qr.executeOnStartup;
        qr.executeOnUser = executeOnUser ?? qr.executeOnUser;
        qr.executeOnAi = executeOnAi ?? qr.executeOnAi;
        qr.executeOnChatChange = executeOnChatChange ?? qr.executeOnChatChange;
        qr.executeOnGroupMemberDraft = executeOnGroupMemberDraft ?? qr.executeOnGroupMemberDraft;
        qr.executeOnNewChat = executeOnNewChat ?? qr.executeOnNewChat;
        qr.automationId = automationId ?? qr.automationId;
        qr.onUpdate();
        return qr;
    }

    /**
     * Deletes an existing quick reply.
     *
     * @param {string} setName name of the existing quick reply set
     * @param {string|number} label label of the existing quick reply (text on the button) or its numeric ID
     */
    deleteQuickReply(setName, label) {
        const qr = this.getQrByLabel(setName, label);
        if (!qr) {
            throw new Error(`No quick reply with label "${label}" in set "${setName}" found.`);
        }
        qr.delete();
    }


    /**
     * Adds an existing quick reply set as a context menu to an existing quick reply.
     *
     * @param {string} setName name of the existing quick reply set containing the quick reply
     * @param {string|number} label label of the existing quick reply or its numeric ID
     * @param {string} contextSetName name of the existing quick reply set to be used as a context menu
     * @param {boolean} isChained whether or not to chain the context menu quick replies
     */
    createContextItem(setName, label, contextSetName, isChained = false) {
        const qr = this.getQrByLabel(setName, label);
        const set = this.getSetByName(contextSetName);
        if (!qr) {
            throw new Error(`No quick reply with label "${label}" in set "${setName}" found.`);
        }
        if (!set) {
            throw new Error(`No quick reply set with name "${contextSetName}" found.`);
        }
        const cl = new QuickReplyContextLink();
        cl.set = set;
        cl.isChained = isChained;
        qr.addContextLink(cl);
    }

    /**
     * Removes a quick reply set from a quick reply's context menu.
     *
     * @param {string} setName name of the existing quick reply set containing the quick reply
     * @param {string|number} label label of the existing quick reply or its numeric ID
     * @param {string} contextSetName name of the existing quick reply set to be used as a context menu
     */
    deleteContextItem(setName, label, contextSetName) {
        const qr = this.getQrByLabel(setName, label);
        const set = this.getSetByName(contextSetName);
        if (!qr) {
            throw new Error(`No quick reply with label "${label}" in set "${setName}" found.`);
        }
        if (!set) {
            throw new Error(`No quick reply set with name "${contextSetName}" found.`);
        }
        qr.removeContextLink(set.name);
    }

    /**
     * Removes all entries from a quick reply's context menu.
     *
     * @param {string} setName name of the existing quick reply set containing the quick reply
     * @param {string|number} label label of the existing quick reply or its numeric ID
     */
    clearContextMenu(setName, label) {
        const qr = this.getQrByLabel(setName, label);
        if (!qr) {
            throw new Error(`No quick reply with label "${label}" in set "${setName}" found.`);
        }
        qr.clearContextLinks();
    }


    /**
     * Create a new quick reply set.
     *
     * @param {string} name name of the new quick reply set
     * @param {object} [props]
     * @param {boolean} [props.disableSend] whether or not to send the quick replies or put the message or slash command into the char input box
     * @param {boolean} [props.placeBeforeInput] whether or not to place the quick reply contents before the existing user input
     * @param {boolean} [props.injectInput] whether or not to automatically inject the user input at the end of the quick reply
     * @returns {Promise<QuickReplySet>} the new quick reply set
     */
    async createSet(name, {
        disableSend,
        placeBeforeInput,
        injectInput,
    } = {}) {
        const set = new QuickReplySet();
        set.name = name;
        set.disableSend = disableSend ?? false;
        set.placeBeforeInput = placeBeforeInput ?? false;
        set.injectInput = injectInput ?? false;
        const oldSet = this.getSetByName(name);
        if (oldSet) {
            QuickReplySet.list.splice(QuickReplySet.list.indexOf(oldSet), 1, set);
        } else {
            const idx = QuickReplySet.list.findIndex(it=>it.name.localeCompare(name) == 1);
            if (idx > -1) {
                QuickReplySet.list.splice(idx, 0, set);
            } else {
                QuickReplySet.list.push(set);
            }
        }
        await set.save();
        this.settingsUi.rerender();
        return set;
    }

    /**
     * Update an existing quick reply set.
     *
     * @param {string} name name of the existing quick reply set
     * @param {object} [props]
     * @param {boolean} [props.disableSend] whether or not to send the quick replies or put the message or slash command into the char input box
     * @param {boolean} [props.placeBeforeInput] whether or not to place the quick reply contents before the existing user input
     * @param {boolean} [props.injectInput] whether or not to automatically inject the user input at the end of the quick reply
     * @returns {Promise<QuickReplySet>} the altered quick reply set
     */
    async updateSet(name, {
        disableSend,
        placeBeforeInput,
        injectInput,
    } = {}) {
        const set = this.getSetByName(name);
        if (!set) {
            throw new Error(`No quick reply set with name "${name}" found.`);
        }
        set.disableSend = disableSend ?? false;
        set.placeBeforeInput = placeBeforeInput ?? false;
        set.injectInput = injectInput ?? false;
        await set.save();
        this.settingsUi.rerender();
        return set;
    }

    /**
     * Delete an existing quick reply set.
     *
     * @param {string} name name of the existing quick reply set
     */
    async deleteSet(name) {
        const set  = this.getSetByName(name);
        if (!set) {
            throw new Error(`No quick reply set with name "${name}" found.`);
        }
        await set.delete();
        this.settingsUi.rerender();
    }


    /**
     * Gets a list of all quick reply sets.
     *
     * @returns array with the names of all quick reply sets
     */
    listSets() {
        return QuickReplySet.list.map(it=>it.name);
    }
    /**
     * Gets a list of all globally active quick reply sets.
     *
     * @returns array with the names of all quick reply sets
     */
    listGlobalSets() {
        return this.settings.config.setList.map(it=>it.set.name);
    }
    /**
     * Gets a list of all quick reply sets activated by the current chat.
     *
     * @returns array with the names of all quick reply sets
     */
    listChatSets() {
        return this.settings.chatConfig?.setList?.flatMap(it=>it.set.name) ?? [];
    }

    /**
     * Gets a list of all quick replies in the quick reply set.
     *
     * @param {string} setName name of the existing quick reply set
     * @returns array with the labels of this set's quick replies
     */
    listQuickReplies(setName) {
        const set = this.getSetByName(setName);
        if (!set) {
            throw new Error(`No quick reply set with name "${name}" found.`);
        }
        return set.qrList.map(it=>it.label);
    }

    /**
     * Gets a list of all Automation IDs used by quick replies.
     *
     * @returns {String[]} array with all automation IDs used by quick replies
     */
    listAutomationIds() {
        return this
            .listSets()
            .flatMap(it => ({ set: it, qrs: this.listQuickReplies(it) }))
            .map(it => it.qrs?.map(qr => this.getQrByLabel(it.set, qr)?.automationId))
            .flat()
            .filter(Boolean)
            .filter(onlyUnique)
            .map(String);
    }
}



---
File: /html/qrEditor.html
---

<div id="qr--modalEditor">
	<div id="qr--main">
		<h3 data-i18n="Labels and Message">Labels and Message</h3>
		<div class="qr--labels">
			<label class="qr--fit">
				<span class="qr--labelText" data-i18n="Label">Icon</span>
				<small class="qr--labelHint">&nbsp;</small>
				<div class="menu_button fa-fw" id="qr--modal-icon" title="Click to change icon"></div>
			</label>
			<div class="label">
				<span class="qr--labelText" data-i18n="Label">Label</span>
				<small class="qr--labelHint" data-i18n="(label of the button, if no icon is chosen) ">(label of the button, if no icon is chosen)</small>
				<div class="qr--inputGroup">
					<label class="checkbox_label" title="Show label even if an icon is assigned">
						<input type="checkbox" id="qr--modal-showLabel">
						Show
					</label>
					<input type="text" class="text_pole" id="qr--modal-label">
					<div class="menu_button fa-fw fa-solid fa-chevron-down" id="qr--modal-switcher" title="Switch to another QR"></div>
				</div>
			</div>
			<label>
				<span class="qr--labelText" data-i18n="Title">Title</span>
				<small class="qr--labelHint" data-i18n="(tooltip, leave empty to show message or /command)">(tooltip, leave empty to show message or /command)</small>
				<input type="text" class="text_pole" id="qr--modal-title">
			</label>
		</div>
		<div class="qr--modal-messageContainer">
			<label for="qr--modal-message" data-i18n="Message / Command:">
				Message / Command:
			</label>
			<div class="qr--modal-editorSettings">
				<label class="checkbox_label">
					<input type="checkbox" id="qr--modal-wrap">
					<span data-i18n="Word wrap">Word wrap</span>
				</label>
				<label class="checkbox_label">
					<span data-i18n="Tab size:">Tab size:</span>
					<input type="number" min="1" max="9" id="qr--modal-tabSize" class="text_pole">
				</label>
				<label class="checkbox_label">
					<input type="checkbox" id="qr--modal-executeShortcut">
					<span data-i18n="Ctrl+Enter to execute">Ctrl+Enter to execute</span>
				</label>
				<label class="checkbox_label">
					<input type="checkbox" id="qr--modal-syntax">
					<span>Syntax highlight</span>
				</label>
				<small>Ctrl+Alt+Click (or F9) to set / remove breakpoints</small>
				<small>Ctrl+<span id="qr--modal-commentKey"></span> to toggle block comments</small>
			</div>
			<div id="qr--modal-messageHolder">
				<pre id="qr--modal-messageSyntax"><code id="qr--modal-messageSyntaxInner" class="hljs language-stscript"></code></pre>
				<textarea id="qr--modal-message" spellcheck="false"></textarea>
			</div>
		</div>
	</div>



	<div id="qr--resizeHandle"></div>



	<div id="qr--qrOptions">
		<h3 data-i18n="Context Menu">Context Menu</h3>
		<div id="qr--ctxEditor">
			<template id="qr--ctxItem">
				<div class="qr--ctxItem" data-order="0">
					<div class="drag-handle ui-sortable-handle">☰</div>
					<select class="qr--set"></select>
					<label class="qr--isChainedLabel checkbox_label" title="When enabled, the current Quick Reply will be sent together with (before) the clicked QR from the context menu.">
						<span data-i18n="Chaining:">Chaining:</span>
						<input type="checkbox" class="qr--isChained">
					</label>
					<div class="qr--delete menu_button menu_button_icon fa-solid fa-trash-can" title="Remove entry"></div>
				</div>
			</template>
		</div>
		<div class="qr--ctxEditorActions">
			<span id="qr--ctxAdd" class="menu_button menu_button_icon fa-solid fa-plus" title="Add quick reply set to context menu"></span>
		</div>


		<h3 data-i18n="Auto-Execute">Auto-Execute</h3>
		<div id="qr--autoExec" class="flex-container flexFlowColumn">
			<label class="checkbox_label" title="Prevent this quick reply from triggering other auto-executed quick replies while auto-executing (i.e., prevent recursive auto-execution)">
				<input type="checkbox" id="qr--preventAutoExecute" >
				<span><i class="fa-solid fa-fw fa-plane-slash"></i><span data-i18n="Don't trigger auto-execute">Don't trigger auto-execute</span></span>
			</label>
			<label class="checkbox_label">
				<input type="checkbox" id="qr--isHidden" >
				<span><i class="fa-solid fa-fw fa-eye-slash"></i><span data-i18n="Invisible (auto-execute only)">Invisible (auto-execute only)</span></span>
			</label>
			<label class="checkbox_label">
				<input type="checkbox" id="qr--executeOnStartup" >
				<span><i class="fa-solid fa-fw fa-rocket"></i><span data-i18n="Execute on startup">Execute on startup</span></span>
			</label>
			<label class="checkbox_label">
				<input type="checkbox" id="qr--executeOnUser" >
				<span><i class="fa-solid fa-fw fa-user"></i><span data-i18n="Execute on user message">Execute on user message</span></span>
			</label>
			<label class="checkbox_label">
				<input type="checkbox" id="qr--executeOnAi" >
				<span><i class="fa-solid fa-fw fa-robot"></i><span data-i18n="Execute on AI message">Execute on AI message</span></span>
			</label>
			<label class="checkbox_label">
				<input type="checkbox" id="qr--executeOnChatChange" >
				<span><i class="fa-solid fa-fw fa-message"></i><span data-i18n="Execute on chat change">Execute on chat change</span></span>
			</label>
            <label class="checkbox_label">
                <input type="checkbox" id="qr--executeOnNewChat">
                <span><i class="fa-solid fa-fw fa-comments"></i><span data-i18n="Execute on new chat">Execute on new chat</span></span>
            </label>
            <label class="checkbox_label">
                <input type="checkbox" id="qr--executeOnGroupMemberDraft">
                <span><i class="fa-solid fa-fw fa-people-group"></i><span data-i18n="Execute on group member draft">Execute on group member draft</span></span>
            </label>
            <div class="flex-container alignItemsBaseline flexFlowColumn flexNoGap" title="Activate this quick reply when a World Info entry with the same Automation ID is triggered.">
                <small data-i18n="Automation ID:">Automation ID</small>
                <input type="text" id="qr--automationId" class="text_pole flex1" placeholder="( None )">
            </div>
		</div>


		<h3 data-i18n="Testing">Testing</h3>
		<div id="qr--modal-executeButtons">
			<div id="qr--modal-execute" class="qr--modal-executeButton menu_button" title="Execute the quick reply now">
				<i class="fa-solid fa-play"></i>
				<span data-i18n="Execute">Execute</span>
			</div>
			<div id="qr--modal-pause" class="qr--modal-executeButton menu_button" title="Pause / continue execution">
				<span class="qr--modal-executeComboIcon">
					<i class="fa-solid fa-play"></i>
					<i class="fa-solid fa-pause"></i>
				</span>
			</div>
			<div id="qr--modal-stop" class="qr--modal-executeButton menu_button" title="Abort execution">
				<i class="fa-solid fa-stop"></i>
			</div>
		</div>
		<div id="qr--modal-executeProgress"></div>
		<div id="qr--modal-executeErrors"></div>
		<div id="qr--modal-executeResult"></div>

		<div id="qr--modal-debugButtons">
			<div title="Resume" id="qr--modal-resume" class="qr--modal-debugButton menu_button"></div>
			<div title="Step Over" id="qr--modal-step" class="qr--modal-debugButton menu_button"></div>
			<div title="Step Into" id="qr--modal-stepInto" class="qr--modal-debugButton menu_button"></div>
			<div title="Step Out" id="qr--modal-stepOut" class="qr--modal-debugButton menu_button"></div>
			<div title="Minimize" id="qr--modal-minimize" class="qr--modal-debugButton menu_button fa-solid fa-minimize"></div>
			<div title="Maximize" id="qr--modal-maximize" class="qr--modal-debugButton menu_button fa-solid fa-maximize"></div>
		</div>
		<textarea rows="1" id="qr--modal-send_textarea" placeholder="Chat input for use with {{input}}" title="Chat input for use with {{input}}"></textarea>
		<div id="qr--modal-debugState"></div>
	</div>
</div>



---
File: /html/settings.html
---

<div id="qr--settings">
	<div class="inline-drawer">
		<div class="inline-drawer-toggle inline-drawer-header">
			<strong data-i18n="Quick Reply">Quick Reply</strong>
			<div class="inline-drawer-icon fa-solid fa-circle-chevron-down down"></div>
		</div>
		<div class="inline-drawer-content">
			<label class="flex-container">
				<input type="checkbox" id="qr--isEnabled"><span data-i18n="Enable Quick Replies">Enable Quick Replies</span>
			</label>
			<label class="flex-container">
				<input type="checkbox" id="qr--isCombined"><span data-i18n="Combine Quick Replies">Combine Quick Replies</span>
			</label>
            <label class="flex-container">
                <input type="checkbox" id="qr--showPopoutButton"><span data-i18n="Show Popout Button">Show Popout Button (on Desktop)</span>
            </label>

			<hr>

			<div id="qr--global">
				<div class="qr--head">
					<div class="qr--title" data-i18n="Global Quick Reply Sets">Global Quick Reply Sets</div>
					<div class="qr--actions">
						<div class="qr--setListAdd menu_button menu_button_icon fa-solid fa-plus" id="qr--global-setListAdd" title="Add quick reply set"></div>
					</div>
				</div>
				<div id="qr--global-setList" class="qr--setList"></div>
			</div>

			<hr>

			<div id="qr--chat">
				<div class="qr--head">
					<div class="qr--title" data-i18n="Chat Quick Reply Sets">Chat Quick Reply Sets</div>
					<div class="qr--actions">
						<div class="qr--setListAdd menu_button menu_button_icon fa-solid fa-plus" id="qr--chat-setListAdd" title="Add quick reply set"></div>
					</div>
				</div>
				<div id="qr--chat-setList" class="qr--setList"></div>
			</div>

			<hr>

			<div id="qr--editor">
				<div class="qr--head">
					<div class="qr--title" data-i18n="Edit Quick Replies">Edit Quick Replies</div>
					<div class="qr--actions">
						<select id="qr--set" class="text_pole"></select>
						<div class="qr--add menu_button menu_button_icon fa-solid fa-plus" id="qr--set-new" title="Create new quick reply set"></div>
						<div class="qr--add menu_button menu_button_icon fa-solid fa-file-import" id="qr--set-import" title="Import quick reply set"></div>
						<input type="file" id="qr--set-importFile" accept=".json" hidden>
						<div class="qr--add menu_button menu_button_icon fa-solid fa-file-export" id="qr--set-export" title="Export quick reply set"></div>
						<div class="qr--del menu_button menu_button_icon fa-solid fa-trash redWarningBG" id="qr--set-delete" title="Delete quick reply set"></div>
					</div>
				</div>
				<div id="qr--set-settings">
					<label class="flex-container">
						<input type="checkbox" id="qr--disableSend"> <span data-i18n="Disable Send (Insert Into Input Field)">Disable send (insert into input field)</span>
					</label>
					<label class="flex-container">
						<input type="checkbox" id="qr--placeBeforeInput"> <span data-i18n="Place Quick Reply Before Input">Place quick reply before input</span>
					</label>
					<label class="flex-container" id="qr--injectInputContainer">
						<input type="checkbox" id="qr--injectInput"> <span><span data-i18n="Inject user input automatically">Inject user input automatically</span> <small><span data-i18n="(if disabled, use ">(if disabled, use</span><code>{{input}}</code> <span data-i18n="macro for manual injection)">macro for manual injection)</span></small></span>
					</label>
					<div class="flex-container alignItemsCenter">
						<toolcool-color-picker id="qr--color"></toolcool-color-picker>
						<div class="menu_button" id="qr--colorClear">Clear</div>
						<span data-i18n="Color">Color</span>
					</div>
					<label class="flex-container" id="qr--onlyBorderColorContainer">
						<input type="checkbox" id="qr--onlyBorderColor"> <span data-i18n="Only apply color as accent">Only apply color as accent</span>
					</label>
				</div>
				<div id="qr--set-qrList" class="qr--qrList"></div>
				<div class="qr--set-qrListActions">
					<div class="qr--add menu_button menu_button_icon fa-solid fa-plus" id="qr--set-add" title="Add quick reply"></div>
					<div class="qr--paste menu_button menu_button_icon fa-solid fa-paste" id="qr--set-paste" title="Paste quick reply from clipboard"></div>
					<div class="qr--import menu_button menu_button_icon fa-solid fa-file-import" id="qr--set-importQr" title="Import quick reply from file"></div>
				</div>
			</div>
		</div>
	</div>
</div>



---
File: /lib/morphdom-esm.js
---

var DOCUMENT_FRAGMENT_NODE = 11;

function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;

    // document-fragments dont have attributes so lets not do anything
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }

    // update attributes on original DOM element
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
        attr = toNodeAttrs[i];
        attrName = attr.name;
        attrNamespaceURI = attr.namespaceURI;
        attrValue = attr.value;

        if (attrNamespaceURI) {
            attrName = attr.localName || attrName;
            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);

            if (fromValue !== attrValue) {
                if (attr.prefix === 'xmlns'){
                    attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix
                }
                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
            }
        } else {
            fromValue = fromNode.getAttribute(attrName);

            if (fromValue !== attrValue) {
                fromNode.setAttribute(attrName, attrValue);
            }
        }
    }

    // Remove any extra attributes found on the original DOM element that
    // weren't found on the target element.
    var fromNodeAttrs = fromNode.attributes;

    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
        attr = fromNodeAttrs[d];
        attrName = attr.name;
        attrNamespaceURI = attr.namespaceURI;

        if (attrNamespaceURI) {
            attrName = attr.localName || attrName;

            if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
                fromNode.removeAttributeNS(attrNamespaceURI, attrName);
            }
        } else {
            if (!toNode.hasAttribute(attrName)) {
                fromNode.removeAttribute(attrName);
            }
        }
    }
}

var range; // Create a range object for efficently rendering strings to elements.
var NS_XHTML = 'http://www.w3.org/1999/xhtml';

var doc = typeof document === 'undefined' ? undefined : document;
var HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');
var HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();

function createFragmentFromTemplate(str) {
    var template = doc.createElement('template');
    template.innerHTML = str;
    return template.content.childNodes[0];
}

function createFragmentFromRange(str) {
    if (!range) {
        range = doc.createRange();
        range.selectNode(doc.body);
    }

    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
}

function createFragmentFromWrap(str) {
    var fragment = doc.createElement('body');
    fragment.innerHTML = str;
    return fragment.childNodes[0];
}

/**
 * This is about the same
 * var html = new DOMParser().parseFromString(str, 'text/html');
 * return html.body.firstChild;
 *
 * @method toElement
 * @param {String} str
 */
function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which
      // createContextualFragment doesn't support
      // <template> support not available in IE
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }

    return createFragmentFromWrap(str);
}

/**
 * Returns true if two node's names are the same.
 *
 * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same
 *       nodeName and different namespace URIs.
 *
 * @param {Element} a
 * @param {Element} b The target element
 * @return {boolean}
 */
function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;

    if (fromNodeName === toNodeName) {
        return true;
    }

    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);

    // If the target element is a virtual DOM node or SVG node then we may
    // need to normalize the tag name before comparing. Normal HTML elements that are
    // in the "http://www.w3.org/1999/xhtml"
    // are converted to upper case
    if (fromCodeStart <= 90 && toCodeStart >= 97) { // from is upper and to is lower
        return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) { // to is upper and from is lower
        return toNodeName === fromNodeName.toUpperCase();
    } else {
        return false;
    }
}

/**
 * Create an element, optionally with a known namespace URI.
 *
 * @param {string} name the element name, e.g. 'div' or 'svg'
 * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of
 * its `xmlns` attribute or its inferred namespace.
 *
 * @return {Element}
 */
function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ?
        doc.createElement(name) :
        doc.createElementNS(namespaceURI, name);
}

/**
 * Copies the children of one DOM element to another DOM element
 */
function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
        var nextChild = curChild.nextSibling;
        toEl.appendChild(curChild);
        curChild = nextChild;
    }
    return toEl;
}

function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
        fromEl[name] = toEl[name];
        if (fromEl[name]) {
            fromEl.setAttribute(name, '');
        } else {
            fromEl.removeAttribute(name);
        }
    }
}

var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
        var parentNode = fromEl.parentNode;
        if (parentNode) {
            var parentName = parentNode.nodeName.toUpperCase();
            if (parentName === 'OPTGROUP') {
                parentNode = parentNode.parentNode;
                parentName = parentNode && parentNode.nodeName.toUpperCase();
            }
            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {
                if (fromEl.hasAttribute('selected') && !toEl.selected) {
                    // Workaround for MS Edge bug where the 'selected' attribute can only be
                    // removed if set to a non-empty value:
                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/
                    fromEl.setAttribute('selected', 'selected');
                    fromEl.removeAttribute('selected');
                }
                // We have to reset select element's selectedIndex to -1, otherwise setting
                // fromEl.selected using the syncBooleanAttrProp below has no effect.
                // The correct selectedIndex will be set in the SELECT special handler below.
                parentNode.selectedIndex = -1;
            }
        }
        syncBooleanAttrProp(fromEl, toEl, 'selected');
    },
    /**
     * The "value" attribute is special for the <input> element since it sets
     * the initial value. Changing the "value" attribute without changing the
     * "value" property will have no effect since it is only used to the set the
     * initial value.  Similar for the "checked" attribute, and "disabled".
     */
    INPUT: function(fromEl, toEl) {
        syncBooleanAttrProp(fromEl, toEl, 'checked');
        syncBooleanAttrProp(fromEl, toEl, 'disabled');

        if (fromEl.value !== toEl.value) {
            fromEl.value = toEl.value;
        }

        if (!toEl.hasAttribute('value')) {
            fromEl.removeAttribute('value');
        }
    },

    TEXTAREA: function(fromEl, toEl) {
        var newValue = toEl.value;
        if (fromEl.value !== newValue) {
            fromEl.value = newValue;
        }

        var firstChild = fromEl.firstChild;
        if (firstChild) {
            // Needed for IE. Apparently IE sets the placeholder as the
            // node value and vise versa. This ignores an empty update.
            var oldValue = firstChild.nodeValue;

            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {
                return;
            }

            firstChild.nodeValue = newValue;
        }
    },
    SELECT: function(fromEl, toEl) {
        if (!toEl.hasAttribute('multiple')) {
            var selectedIndex = -1;
            var i = 0;
            // We have to loop through children of fromEl, not toEl since nodes can be moved
            // from toEl to fromEl directly when morphing.
            // At the time this special handler is invoked, all children have already been morphed
            // and appended to / removed from fromEl, so using fromEl here is safe and correct.
            var curChild = fromEl.firstChild;
            var optgroup;
            var nodeName;
            while(curChild) {
                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
                if (nodeName === 'OPTGROUP') {
                    optgroup = curChild;
                    curChild = optgroup.firstChild;
                } else {
                    if (nodeName === 'OPTION') {
                        if (curChild.hasAttribute('selected')) {
                            selectedIndex = i;
                            break;
                        }
                        i++;
                    }
                    curChild = curChild.nextSibling;
                    if (!curChild && optgroup) {
                        curChild = optgroup.nextSibling;
                        optgroup = null;
                    }
                }
            }

            fromEl.selectedIndex = selectedIndex;
        }
    }
};

var ELEMENT_NODE = 1;
var DOCUMENT_FRAGMENT_NODE$1 = 11;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;

function noop() {}

function defaultGetNodeKey(node) {
  if (node) {
    return (node.getAttribute && node.getAttribute('id')) || node.id;
  }
}

function morphdomFactory(morphAttrs) {

  return function morphdom(fromNode, toNode, options) {
    if (!options) {
      options = {};
    }

    if (typeof toNode === 'string') {
      if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML' || fromNode.nodeName === 'BODY') {
        var toNodeHtml = toNode;
        toNode = doc.createElement('html');
        toNode.innerHTML = toNodeHtml;
      } else {
        toNode = toElement(toNode);
      }
    } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
      toNode = toNode.firstElementChild;
    }

    var getNodeKey = options.getNodeKey || defaultGetNodeKey;
    var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
    var onNodeAdded = options.onNodeAdded || noop;
    var onBeforeElUpdated = options.onBeforeElUpdated || noop;
    var onElUpdated = options.onElUpdated || noop;
    var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
    var onNodeDiscarded = options.onNodeDiscarded || noop;
    var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
    var skipFromChildren = options.skipFromChildren || noop;
    var addChild = options.addChild || function(parent, child){ return parent.appendChild(child); };
    var childrenOnly = options.childrenOnly === true;

    // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.
    var fromNodesLookup = Object.create(null);
    var keyedRemovalList = [];

    function addKeyedRemoval(key) {
      keyedRemovalList.push(key);
    }

    function walkDiscardedChildNodes(node, skipKeyedNodes) {
      if (node.nodeType === ELEMENT_NODE) {
        var curChild = node.firstChild;
        while (curChild) {

          var key = undefined;

          if (skipKeyedNodes && (key = getNodeKey(curChild))) {
            // If we are skipping keyed nodes then we add the key
            // to a list so that it can be handled at the very end.
            addKeyedRemoval(key);
          } else {
            // Only report the node as discarded if it is not keyed. We do this because
            // at the end we loop through all keyed elements that were unmatched
            // and then discard them in one final pass.
            onNodeDiscarded(curChild);
            if (curChild.firstChild) {
              walkDiscardedChildNodes(curChild, skipKeyedNodes);
            }
          }

          curChild = curChild.nextSibling;
        }
      }
    }

    /**
    * Removes a DOM node out of the original DOM
    *
    * @param  {Node} node The node to remove
    * @param  {Node} parentNode The nodes parent
    * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.
    * @return {undefined}
    */
    function removeNode(node, parentNode, skipKeyedNodes) {
      if (onBeforeNodeDiscarded(node) === false) {
        return;
      }

      if (parentNode) {
        parentNode.removeChild(node);
      }

      onNodeDiscarded(node);
      walkDiscardedChildNodes(node, skipKeyedNodes);
    }

    // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future
    // function indexTree(root) {
    //     var treeWalker = document.createTreeWalker(
    //         root,
    //         NodeFilter.SHOW_ELEMENT);
    //
    //     var el;
    //     while((el = treeWalker.nextNode())) {
    //         var key = getNodeKey(el);
    //         if (key) {
    //             fromNodesLookup[key] = el;
    //         }
    //     }
    // }

    // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future
    //
    // function indexTree(node) {
    //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);
    //     var el;
    //     while((el = nodeIterator.nextNode())) {
    //         var key = getNodeKey(el);
    //         if (key) {
    //             fromNodesLookup[key] = el;
    //         }
    //     }
    // }

    function indexTree(node) {
      if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
        var curChild = node.firstChild;
        while (curChild) {
          var key = getNodeKey(curChild);
          if (key) {
            fromNodesLookup[key] = curChild;
          }

          // Walk recursively
          indexTree(curChild);

          curChild = curChild.nextSibling;
        }
      }
    }

    indexTree(fromNode);

    function handleNodeAdded(el) {
      onNodeAdded(el);

      var curChild = el.firstChild;
      while (curChild) {
        var nextSibling = curChild.nextSibling;

        var key = getNodeKey(curChild);
        if (key) {
          var unmatchedFromEl = fromNodesLookup[key];
          // if we find a duplicate #id node in cache, replace `el` with cache value
          // and morph it to the child node.
          if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
            curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
            morphEl(unmatchedFromEl, curChild);
          } else {
            handleNodeAdded(curChild);
          }
        } else {
          // recursively call for curChild and it's children to see if we find something in
          // fromNodesLookup
          handleNodeAdded(curChild);
        }

        curChild = nextSibling;
      }
    }

    function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
      // We have processed all of the "to nodes". If curFromNodeChild is
      // non-null then we still have some from nodes left over that need
      // to be removed
      while (curFromNodeChild) {
        var fromNextSibling = curFromNodeChild.nextSibling;
        if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {
          // Since the node is keyed it might be matched up later so we defer
          // the actual removal to later
          addKeyedRemoval(curFromNodeKey);
        } else {
          // NOTE: we skip nested keyed nodes from being removed since there is
          //       still a chance they will be matched up later
          removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
        }
        curFromNodeChild = fromNextSibling;
      }
    }

    function morphEl(fromEl, toEl, childrenOnly) {
      var toElKey = getNodeKey(toEl);

      if (toElKey) {
        // If an element with an ID is being morphed then it will be in the final
        // DOM so clear it out of the saved elements collection
        delete fromNodesLookup[toElKey];
      }

      if (!childrenOnly) {
        // optional
        var beforeUpdateResult = onBeforeElUpdated(fromEl, toEl);
        if (beforeUpdateResult === false) {
          return;
        } else if (beforeUpdateResult instanceof HTMLElement) {
          fromEl = beforeUpdateResult;
          // reindex the new fromEl in case it's not in the same
          // tree as the original fromEl
          // (Phoenix LiveView sometimes returns a cloned tree,
          //  but keyed lookups would still point to the original tree)
          indexTree(fromEl);
        }

        // update attributes on original DOM element first
        morphAttrs(fromEl, toEl);
        // optional
        onElUpdated(fromEl);

        if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
          return;
        }
      }

      if (fromEl.nodeName !== 'TEXTAREA') {
        morphChildren(fromEl, toEl);
      } else {
        specialElHandlers.TEXTAREA(fromEl, toEl);
      }
    }

    function morphChildren(fromEl, toEl) {
      var skipFrom = skipFromChildren(fromEl, toEl);
      var curToNodeChild = toEl.firstChild;
      var curFromNodeChild = fromEl.firstChild;
      var curToNodeKey;
      var curFromNodeKey;

      var fromNextSibling;
      var toNextSibling;
      var matchingFromEl;

      // walk the children
      outer: while (curToNodeChild) {
        toNextSibling = curToNodeChild.nextSibling;
        curToNodeKey = getNodeKey(curToNodeChild);

        // walk the fromNode children all the way through
        while (!skipFrom && curFromNodeChild) {
          fromNextSibling = curFromNodeChild.nextSibling;

          if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
            continue outer;
          }

          curFromNodeKey = getNodeKey(curFromNodeChild);

          var curFromNodeType = curFromNodeChild.nodeType;

          // this means if the curFromNodeChild doesnt have a match with the curToNodeChild
          var isCompatible = undefined;

          if (curFromNodeType === curToNodeChild.nodeType) {
            if (curFromNodeType === ELEMENT_NODE) {
              // Both nodes being compared are Element nodes

              if (curToNodeKey) {
                // The target node has a key so we want to match it up with the correct element
                // in the original DOM tree
                if (curToNodeKey !== curFromNodeKey) {
                  // The current element in the original DOM tree does not have a matching key so
                  // let's check our lookup to see if there is a matching element in the original
                  // DOM tree
                  if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {
                    if (fromNextSibling === matchingFromEl) {
                      // Special case for single element removals. To avoid removing the original
                      // DOM node out of the tree (since that can break CSS transitions, etc.),
                      // we will instead discard the current node and wait until the next
                      // iteration to properly match up the keyed target element with its matching
                      // element in the original tree
                      isCompatible = false;
                    } else {
                      // We found a matching keyed element somewhere in the original DOM tree.
                      // Let's move the original DOM node into the current position and morph
                      // it.

                      // NOTE: We use insertBefore instead of replaceChild because we want to go through
                      // the `removeNode()` function for the node that is being discarded so that
                      // all lifecycle hooks are correctly invoked
                      fromEl.insertBefore(matchingFromEl, curFromNodeChild);

                      // fromNextSibling = curFromNodeChild.nextSibling;

                      if (curFromNodeKey) {
                        // Since the node is keyed it might be matched up later so we defer
                        // the actual removal to later
                        addKeyedRemoval(curFromNodeKey);
                      } else {
                        // NOTE: we skip nested keyed nodes from being removed since there is
                        //       still a chance they will be matched up later
                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
                      }

                      curFromNodeChild = matchingFromEl;
                      curFromNodeKey = getNodeKey(curFromNodeChild);
                    }
                  } else {
                    // The nodes are not compatible since the "to" node has a key and there
                    // is no matching keyed node in the source tree
                    isCompatible = false;
                  }
                }
              } else if (curFromNodeKey) {
                // The original has a key
                isCompatible = false;
              }

              isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
              if (isCompatible) {
                // We found compatible DOM elements so transform
                // the current "from" node to match the current
                // target DOM node.
                // MORPH
                morphEl(curFromNodeChild, curToNodeChild);
              }

            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
              // Both nodes being compared are Text or Comment nodes
              isCompatible = true;
              // Simply update nodeValue on the original node to
              // change the text value
              if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
              }

            }
          }

          if (isCompatible) {
            // Advance both the "to" child and the "from" child since we found a match
            // Nothing else to do as we already recursively called morphChildren above
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
            continue outer;
          }

          // No compatible match so remove the old node from the DOM and continue trying to find a
          // match in the original DOM. However, we only do this if the from node is not keyed
          // since it is possible that a keyed node might match up with a node somewhere else in the
          // target tree and we don't want to discard it just yet since it still might find a
          // home in the final DOM tree. After everything is done we will remove any keyed nodes
          // that didn't find a home
          if (curFromNodeKey) {
            // Since the node is keyed it might be matched up later so we defer
            // the actual removal to later
            addKeyedRemoval(curFromNodeKey);
          } else {
            // NOTE: we skip nested keyed nodes from being removed since there is
            //       still a chance they will be matched up later
            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
          }

          curFromNodeChild = fromNextSibling;
        } // END: while(curFromNodeChild) {}

        // If we got this far then we did not find a candidate match for
        // our "to node" and we exhausted all of the children "from"
        // nodes. Therefore, we will just append the current "to" node
        // to the end
        if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
          // MORPH
          if(!skipFrom){ addChild(fromEl, matchingFromEl); }
          morphEl(matchingFromEl, curToNodeChild);
        } else {
          var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
          if (onBeforeNodeAddedResult !== false) {
            if (onBeforeNodeAddedResult) {
              curToNodeChild = onBeforeNodeAddedResult;
            }

            if (curToNodeChild.actualize) {
              curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
            }
            addChild(fromEl, curToNodeChild);
            handleNodeAdded(curToNodeChild);
          }
        }

        curToNodeChild = toNextSibling;
        curFromNodeChild = fromNextSibling;
      }

      cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);

      var specialElHandler = specialElHandlers[fromEl.nodeName];
      if (specialElHandler) {
        specialElHandler(fromEl, toEl);
      }
    } // END: morphChildren(...)

    var morphedNode = fromNode;
    var morphedNodeType = morphedNode.nodeType;
    var toNodeType = toNode.nodeType;

    if (!childrenOnly) {
      // Handle the case where we are given two DOM nodes that are not
      // compatible (e.g. <div> --> <span> or <div> --> TEXT)
      if (morphedNodeType === ELEMENT_NODE) {
        if (toNodeType === ELEMENT_NODE) {
          if (!compareNodeNames(fromNode, toNode)) {
            onNodeDiscarded(fromNode);
            morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
          }
        } else {
          // Going from an element node to a text node
          morphedNode = toNode;
        }
      } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node
        if (toNodeType === morphedNodeType) {
          if (morphedNode.nodeValue !== toNode.nodeValue) {
            morphedNode.nodeValue = toNode.nodeValue;
          }

          return morphedNode;
        } else {
          // Text node to something else
          morphedNode = toNode;
        }
      }
    }

    if (morphedNode === toNode) {
      // The "to node" was not compatible with the "from node" so we had to
      // toss out the "from node" and use the "to node"
      onNodeDiscarded(fromNode);
    } else {
      if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
        return;
      }

      morphEl(morphedNode, toNode, childrenOnly);

      // We now need to loop over any keyed nodes that might need to be
      // removed. We only do the removal if we know that the keyed node
      // never found a match. When a keyed node is matched up we remove
      // it out of fromNodesLookup and we use fromNodesLookup to determine
      // if a keyed node has been matched up or not
      if (keyedRemovalList) {
        for (var i=0, len=keyedRemovalList.length; i<len; i++) {
          var elToRemove = fromNodesLookup[keyedRemovalList[i]];
          if (elToRemove) {
            removeNode(elToRemove, elToRemove.parentNode, false);
          }
        }
      }
    }

    if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
      if (morphedNode.actualize) {
        morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
      }
      // If we had to swap out the from node with a new node because the old
      // node was not compatible with the target node then we need to
      // replace the old DOM node in the original DOM tree. This is only
      // possible if the original DOM node was part of a DOM tree which
      // we know is the case if it has a parent node.
      fromNode.parentNode.replaceChild(morphedNode, fromNode);
    }

    return morphedNode;
  };
}

var morphdom = morphdomFactory(morphAttrs);

export default morphdom;



---
File: /src/ui/ctx/ContextMenu.js
---

import { QuickReply } from '../../QuickReply.js';
// eslint-disable-next-line no-unused-vars
import { QuickReplySet } from '../../QuickReplySet.js';
import { MenuHeader } from './MenuHeader.js';
import { MenuItem } from './MenuItem.js';

export class ContextMenu {
    /**@type {MenuItem[]}*/ itemList = [];
    /**@type {Boolean}*/ isActive = false;

    /**@type {HTMLElement}*/ root;
    /**@type {HTMLElement}*/ menu;




    constructor(/**@type {QuickReply}*/qr) {
        // this.itemList = items;
        this.itemList = this.build(qr).children;
        this.itemList.forEach(item => {
            item.onExpand = () => {
                this.itemList.filter(it => it != item)
                    .forEach(it => it.collapse());
            };
        });
    }

    /**
     * @param {QuickReply} qr
     * @param {String} chainedMessage
     * @param {QuickReplySet[]} hierarchy
     * @param {String[]} labelHierarchy
     */
    build(qr, chainedMessage = null, hierarchy = [], labelHierarchy = []) {
        const tree = {
            icon: qr.icon,
            showLabel: qr.showLabel,
            label: qr.label,
            message: (chainedMessage && qr.message ? `${chainedMessage} | ` : '') + qr.message,
            children: [],
        };
        qr.contextList.forEach((cl) => {
            if (!cl.set) return;
            if (!hierarchy.includes(cl.set)) {
                const nextHierarchy = [...hierarchy, cl.set];
                const nextLabelHierarchy = [...labelHierarchy, tree.label];
                tree.children.push(new MenuHeader(cl.set.name));
                cl.set.qrList.forEach(subQr => {
                    const subTree = this.build(subQr, cl.isChained ? tree.message : null, nextHierarchy, nextLabelHierarchy);
                    tree.children.push(new MenuItem(
                        subTree.icon,
                        subTree.showLabel,
                        subTree.label,
                        subTree.message,
                        (evt) => {
                            evt.stopPropagation();
                            const finalQr = Object.assign(new QuickReply(), subQr);
                            finalQr.message = subTree.message.replace(/%%parent(-\d+)?%%/g, (_, index) => {
                                return nextLabelHierarchy.slice(parseInt(index ?? '-1'))[0];
                            });
                            cl.set.execute(finalQr);
                        },
                        subTree.children,
                    ));
                });
            }
        });
        return tree;
    }

    render() {
        if (!this.root) {
            const blocker = document.createElement('div'); {
                this.root = blocker;
                blocker.classList.add('ctx-blocker');
                blocker.addEventListener('click', () => this.hide());
                const menu = document.createElement('ul'); {
                    this.menu = menu;
                    menu.classList.add('list-group');
                    menu.classList.add('ctx-menu');
                    this.itemList.forEach(it => menu.append(it.render()));
                    blocker.append(menu);
                }
            }
        }
        return this.root;
    }




    show({ clientX, clientY }) {
        if (this.isActive) return;
        this.isActive = true;
        this.render();
        this.menu.style.bottom = `${window.innerHeight - clientY}px`;
        this.menu.style.left = `${clientX}px`;
        document.body.append(this.root);
    }
    hide() {
        if (this.root) {
            this.root.remove();
        }
        this.isActive = false;
    }
    toggle(/**@type {PointerEvent}*/evt) {
        if (this.isActive) {
            this.hide();
        } else {
            this.show(evt);
        }
    }
}



---
File: /src/ui/ctx/MenuHeader.js
---

import { MenuItem } from './MenuItem.js';

export class MenuHeader extends MenuItem {
    constructor(/**@type {String}*/label) {
        super(null, null, label, null, null);
    }


    render() {
        if (!this.root) {
            const item = document.createElement('li'); {
                this.root = item;
                item.classList.add('list-group-item');
                item.classList.add('ctx-header');
                item.append(this.label);
            }
        }
        return this.root;
    }
}



---
File: /src/ui/ctx/MenuItem.js
---

import { SubMenu } from './SubMenu.js';

export class MenuItem {
    /**@type {string}*/ icon;
    /**@type {boolean}*/ showLabel;
    /**@type {string}*/ label;
    /**@type {object}*/ value;
    /**@type {function}*/ callback;
    /**@type {MenuItem[]}*/ childList = [];
    /**@type {SubMenu}*/ subMenu;
    /**@type {boolean}*/ isForceExpanded = false;

    /**@type {HTMLElement}*/ root;

    /**@type {function}*/ onExpand;




    /**
     *
     * @param {string} icon
     * @param {boolean} showLabel
     * @param {string} label
     * @param {object} value
     * @param {function} callback
     * @param {MenuItem[]} children
     */
    constructor(icon, showLabel, label, value, callback, children = []) {
        this.icon = icon;
        this.showLabel = showLabel;
        this.label = label;
        this.value = value;
        this.callback = callback;
        this.childList = children;
    }


    render() {
        if (!this.root) {
            const item = document.createElement('li'); {
                this.root = item;
                item.classList.add('list-group-item');
                item.classList.add('ctx-item');
                item.title = this.value;
                if (this.callback) {
                    item.addEventListener('click', (evt) => this.callback(evt, this));
                }
                const icon = document.createElement('div'); {
                    this.domIcon = icon;
                    icon.classList.add('qr--button-icon');
                    icon.classList.add('fa-solid');
                    if (!this.icon) icon.classList.add('qr--hidden');
                    else icon.classList.add(this.icon);
                    item.append(icon);
                }
                const lbl = document.createElement('div'); {
                    this.domLabel = lbl;
                    lbl.classList.add('qr--button-label');
                    if (this.icon && !this.showLabel) lbl.classList.add('qr--hidden');
                    lbl.textContent = this.label;
                    item.append(lbl);
                }
                if (this.childList.length > 0) {
                    item.classList.add('ctx-has-children');
                    const sub = new SubMenu(this.childList);
                    this.subMenu = sub;
                    const trigger = document.createElement('div'); {
                        trigger.classList.add('ctx-expander');
                        trigger.textContent = '⋮';
                        trigger.addEventListener('click', (evt) => {
                            evt.stopPropagation();
                            this.toggle();
                        });
                        item.append(trigger);
                    }
                    item.addEventListener('mouseover', () => sub.show(item));
                    item.addEventListener('mouseleave', () => sub.hide());

                }
            }
        }
        return this.root;
    }


    expand() {
        this.subMenu?.show(this.root);
        if (this.onExpand) {
            this.onExpand();
        }
    }
    collapse() {
        this.subMenu?.hide();
    }
    toggle() {
        if (this.subMenu.isActive) {
            this.expand();
        } else {
            this.collapse();
        }
    }
}



---
File: /src/ui/ctx/SubMenu.js
---

/**
 * @typedef {import('./MenuItem.js').MenuItem} MenuItem
 */

export class SubMenu {
    /**@type {MenuItem[]}*/ itemList = [];
    /**@type {Boolean}*/ isActive = false;

    /**@type {HTMLElement}*/ root;




    constructor(/**@type {MenuItem[]}*/items) {
        this.itemList = items;
    }

    render() {
        if (!this.root) {
            const menu = document.createElement('ul'); {
                this.root = menu;
                menu.classList.add('list-group');
                menu.classList.add('ctx-menu');
                menu.classList.add('ctx-sub-menu');
                this.itemList.forEach(it => menu.append(it.render()));
            }
        }
        return this.root;
    }




    show(/**@type {HTMLElement}*/parent) {
        if (this.isActive) return;
        this.isActive = true;
        this.render();
        parent.append(this.root);
        requestAnimationFrame(() => {
            const rect = this.root.getBoundingClientRect();
            console.log(window.innerHeight, rect);
            if (rect.bottom > window.innerHeight - 5) {
                this.root.style.top = `${window.innerHeight - 5 - rect.bottom}px`;
            }
            if (rect.right > window.innerWidth - 5) {
                this.root.style.left = 'unset';
                this.root.style.right = '100%';
            }
        });
    }
    hide() {
        if (this.root) {
            this.root.remove();
            this.root.style.top = '';
            this.root.style.left = '';
        }
        this.isActive = false;
    }
    toggle(/**@type {HTMLElement}*/parent) {
        if (this.isActive) {
            this.hide();
        } else {
            this.show(parent);
        }
    }
}



---
File: /src/ui/ButtonUi.js
---

import { animation_duration } from '../../../../../script.js';
import { dragElement } from '../../../../RossAscends-mods.js';
import { loadMovingUIState } from '../../../../power-user.js';
// eslint-disable-next-line no-unused-vars
import { QuickReplySettings } from '../QuickReplySettings.js';

export class ButtonUi {
    /**@type {QuickReplySettings}*/ settings;

    /**@type {HTMLElement}*/ dom;
    /**@type {HTMLElement}*/ popoutDom;




    constructor(/**@type {QuickReplySettings}*/settings) {
        this.settings = settings;
    }




    render() {
        if (this.settings.isPopout) {
            return this.renderPopout();
        }
        return this.renderBar();
    }
    unrender() {
        this.dom?.remove();
        this.dom = null;
        this.popoutDom?.remove();
        this.popoutDom = null;
    }

    show() {
        if (!this.settings.isEnabled) return;
        if (this.settings.isPopout) {
            document.body.append(this.render());
            loadMovingUIState();
            $(this.render()).fadeIn(animation_duration);
            dragElement($(this.render()));
        } else {
            const sendForm = document.querySelector('#send_form');
            if (sendForm.children.length > 0) {
                sendForm.children[0].insertAdjacentElement('beforebegin', this.render());
            } else {
                sendForm.append(this.render());
            }
        }
    }
    hide() {
        this.unrender();
    }
    refresh() {
        this.hide();
        this.show();
    }




    renderBar() {
        if (!this.dom) {
            let buttonHolder;
            const root = document.createElement('div'); {
                this.dom = root;
                buttonHolder = root;
                root.id = 'qr--bar';
                root.classList.add('flex-container');
                root.classList.add('flexGap5');
                if (this.settings.showPopoutButton) {
                    root.classList.add('popoutVisible');
                    const popout = document.createElement('div'); {
                        popout.id = 'qr--popoutTrigger';
                        popout.classList.add('menu_button');
                        popout.classList.add('fa-solid');
                        popout.classList.add('fa-window-restore');
                        popout.addEventListener('click', ()=>{
                            this.settings.isPopout = true;
                            this.refresh();
                            this.settings.save();
                        });
                        root.append(popout);
                    }
                }
                if (this.settings.isCombined) {
                    const buttons = document.createElement('div'); {
                        buttonHolder = buttons;
                        buttons.classList.add('qr--buttons');
                        root.append(buttons);
                    }
                }
                [...this.settings.config.setList, ...(this.settings.chatConfig?.setList ?? [])]
                    .filter(link=>link.isVisible)
                    .forEach(link=>buttonHolder.append(link.set.render()))
                ;
            }
        }
        return this.dom;
    }




    renderPopout() {
        if (!this.popoutDom) {
            let buttonHolder;
            const root = document.createElement('div'); {
                this.popoutDom = root;
                root.id = 'qr--popout';
                root.classList.add('qr--popout');
                root.classList.add('draggable');
                const head = document.createElement('div'); {
                    head.classList.add('qr--header');
                    root.append(head);
                    const controls = document.createElement('div'); {
                        controls.classList.add('qr--controls');
                        controls.classList.add('panelControlBar');
                        controls.classList.add('flex-container');
                        const drag = document.createElement('div'); {
                            drag.id = 'qr--popoutheader';
                            drag.classList.add('fa-solid');
                            drag.classList.add('fa-grip');
                            drag.classList.add('drag-grabber');
                            drag.classList.add('hoverglow');
                            controls.append(drag);
                        }
                        const close = document.createElement('div'); {
                            close.classList.add('qr--close');
                            close.classList.add('fa-solid');
                            close.classList.add('fa-circle-xmark');
                            close.classList.add('hoverglow');
                            close.addEventListener('click', ()=>{
                                this.settings.isPopout = false;
                                this.refresh();
                                this.settings.save();
                            });
                            controls.append(close);
                        }
                        head.append(controls);
                    }
                }
                const body = document.createElement('div'); {
                    buttonHolder = body;
                    body.classList.add('qr--body');
                    if (this.settings.isCombined) {
                        const buttons = document.createElement('div'); {
                            buttonHolder = buttons;
                            buttons.classList.add('qr--buttons');
                            body.append(buttons);
                        }
                    }
                    [...this.settings.config.setList, ...(this.settings.chatConfig?.setList ?? [])]
                        .filter(link=>link.isVisible)
                        .forEach(link=>buttonHolder.append(link.set.render()))
                    ;
                    root.append(body);
                }
            }
        }
        return this.popoutDom;
    }
}



---
File: /src/ui/SettingsUi.js
---

import { callPopup } from '../../../../../script.js';
import { getSortableDelay } from '../../../../utils.js';
import { log, warn } from '../../index.js';
import { QuickReply } from '../QuickReply.js';
import { QuickReplySet } from '../QuickReplySet.js';
// eslint-disable-next-line no-unused-vars
import { QuickReplySettings } from '../QuickReplySettings.js';

export class SettingsUi {
    /**@type {QuickReplySettings}*/ settings;

    /**@type {HTMLElement}*/ template;
    /**@type {HTMLElement}*/ dom;

    /**@type {HTMLInputElement}*/ isEnabled;
    /**@type {HTMLInputElement}*/ isCombined;
    /**@type {HTMLInputElement}*/ showPopoutButton;

    /**@type {HTMLElement}*/ globalSetList;

    /**@type {HTMLElement}*/ chatSetList;

    /**@type {QuickReplySet}*/ currentQrSet;
    /**@type {HTMLInputElement}*/ disableSend;
    /**@type {HTMLInputElement}*/ placeBeforeInput;
    /**@type {HTMLInputElement}*/ injectInput;
    /**@type {HTMLInputElement}*/ color;
    /**@type {HTMLInputElement}*/ onlyBorderColor;
    /**@type {HTMLSelectElement}*/ currentSet;




    constructor(/**@type {QuickReplySettings}*/settings) {
        this.settings = settings;
        settings.onRequestEditSet = (qrs) => this.selectQrSet(qrs);
    }






    rerender() {
        if (!this.dom) return;
        const content = this.dom.querySelector('.inline-drawer-content');
        content.innerHTML = '';
        // @ts-ignore
        Array.from(this.template.querySelector('.inline-drawer-content').cloneNode(true).children).forEach(el=>{
            content.append(el);
        });
        this.prepareDom();
    }
    unrender() {
        this.dom?.remove();
        this.dom = null;
    }
    async render() {
        if (!this.dom) {
            const response = await fetch('/scripts/extensions/quick-reply/html/settings.html', { cache: 'no-store' });
            if (response.ok) {
                this.template = document.createRange().createContextualFragment(await response.text()).querySelector('#qr--settings');
                // @ts-ignore
                this.dom = this.template.cloneNode(true);
                this.prepareDom();
            } else {
                warn('failed to fetch settings template');
            }
        }
        return this.dom;
    }


    prepareGeneralSettings() {
        // general settings
        this.isEnabled = this.dom.querySelector('#qr--isEnabled');
        this.isEnabled.checked = this.settings.isEnabled;
        this.isEnabled.addEventListener('click', ()=>this.onIsEnabled());

        this.isCombined = this.dom.querySelector('#qr--isCombined');
        this.isCombined.checked = this.settings.isCombined;
        this.isCombined.addEventListener('click', ()=>this.onIsCombined());

        this.showPopoutButton = this.dom.querySelector('#qr--showPopoutButton');
        this.showPopoutButton.checked = this.settings.showPopoutButton;
        this.showPopoutButton.addEventListener('click', ()=>this.onShowPopoutButton());
    }

    prepareGlobalSetList() {
        const dom = this.template.querySelector('#qr--global');
        const clone = dom.cloneNode(true);
        // @ts-ignore
        this.settings.config.renderSettingsInto(clone);
        this.dom.querySelector('#qr--global').replaceWith(clone);
    }
    prepareChatSetList() {
        const dom = this.template.querySelector('#qr--chat');
        const clone = dom.cloneNode(true);
        if (this.settings.chatConfig) {
            // @ts-ignore
            this.settings.chatConfig.renderSettingsInto(clone);
        } else {
            const info = document.createElement('div'); {
                info.textContent = 'No active chat.';
                // @ts-ignore
                clone.append(info);
            }
        }
        this.dom.querySelector('#qr--chat').replaceWith(clone);
    }

    prepareQrEditor() {
        // qr editor
        this.dom.querySelector('#qr--set-new').addEventListener('click', async()=>this.addQrSet());
        /**@type {HTMLInputElement}*/
        const importFile = this.dom.querySelector('#qr--set-importFile');
        importFile.addEventListener('change', async()=>{
            await this.importQrSet(importFile.files);
            importFile.value = null;
        });
        this.dom.querySelector('#qr--set-import').addEventListener('click', ()=>importFile.click());
        this.dom.querySelector('#qr--set-export').addEventListener('click', async()=>this.exportQrSet());
        this.dom.querySelector('#qr--set-delete').addEventListener('click', async()=>this.deleteQrSet());
        this.dom.querySelector('#qr--set-add').addEventListener('click', async()=>{
            this.currentQrSet.addQuickReply();
        });
        this.dom.querySelector('#qr--set-paste').addEventListener('click', async()=>{
            const text = await navigator.clipboard.readText();
            this.currentQrSet.addQuickReplyFromText(text);
        });
        this.dom.querySelector('#qr--set-importQr').addEventListener('click', async()=>{
            const inp = document.createElement('input'); {
                inp.type = 'file';
                inp.accept = '.json';
                inp.addEventListener('change', async()=>{
                    if (inp.files.length > 0) {
                        for (const file of inp.files) {
                            const text = await file.text();
                            this.currentQrSet.addQuickReply(JSON.parse(text));
                        }
                    }
                });
                inp.click();
            }
        });
        this.qrList = this.dom.querySelector('#qr--set-qrList');
        this.currentSet = this.dom.querySelector('#qr--set');
        this.currentSet.addEventListener('change', ()=>this.onQrSetChange());
        QuickReplySet.list.toSorted((a,b)=>a.name.toLowerCase().localeCompare(b.name.toLowerCase())).forEach(qrs=>{
            const opt = document.createElement('option'); {
                opt.value = qrs.name;
                opt.textContent = qrs.name;
                this.currentSet.append(opt);
            }
        });
        this.disableSend = this.dom.querySelector('#qr--disableSend');
        this.disableSend.addEventListener('click', ()=>{
            const qrs = this.currentQrSet;
            qrs.disableSend = this.disableSend.checked;
            qrs.save();
        });
        this.placeBeforeInput = this.dom.querySelector('#qr--placeBeforeInput');
        this.placeBeforeInput.addEventListener('click', ()=>{
            const qrs = this.currentQrSet;
            qrs.placeBeforeInput = this.placeBeforeInput.checked;
            qrs.save();
        });
        this.injectInput = this.dom.querySelector('#qr--injectInput');
        this.injectInput.addEventListener('click', ()=>{
            const qrs = this.currentQrSet;
            qrs.injectInput = this.injectInput.checked;
            qrs.save();
        });
        let initialColorChange = true;
        this.color = this.dom.querySelector('#qr--color');
        this.color.color = this.currentQrSet?.color ?? 'transparent';
        this.color.addEventListener('change', (evt)=>{
            if (!this.dom.closest('body')) return;
            const qrs = this.currentQrSet;
            if (initialColorChange) {
                initialColorChange = false;
                this.color.color = qrs.color;
                return;
            }
            qrs.color = evt.detail.rgb;
            qrs.save();
            this.currentQrSet.updateColor();
        });
        this.dom.querySelector('#qr--colorClear').addEventListener('click', (evt)=>{
            const qrs = this.currentQrSet;
            this.color.color = 'transparent';
            qrs.save();
            this.currentQrSet.updateColor();
        });
        this.onlyBorderColor = this.dom.querySelector('#qr--onlyBorderColor');
        this.onlyBorderColor.addEventListener('click', ()=>{
            const qrs = this.currentQrSet;
            qrs.onlyBorderColor = this.onlyBorderColor.checked;
            qrs.save();
            this.currentQrSet.updateColor();
        });
        this.onQrSetChange();
    }
    onQrSetChange() {
        this.currentQrSet = QuickReplySet.get(this.currentSet.value) ?? new QuickReplySet();
        this.disableSend.checked = this.currentQrSet.disableSend;
        this.placeBeforeInput.checked = this.currentQrSet.placeBeforeInput;
        this.injectInput.checked = this.currentQrSet.injectInput;
        this.color.color = this.currentQrSet.color ?? 'transparent';
        this.onlyBorderColor.checked = this.currentQrSet.onlyBorderColor;
        this.qrList.innerHTML = '';
        const qrsDom = this.currentQrSet.renderSettings();
        this.qrList.append(qrsDom);
        // @ts-ignore
        $(qrsDom).sortable({
            delay: getSortableDelay(),
            handle: '.drag-handle',
            stop: ()=>this.onQrListSort(),
        });
    }


    prepareDom() {
        this.prepareGeneralSettings();
        this.prepareGlobalSetList();
        this.prepareChatSetList();
        this.prepareQrEditor();
    }




    async onIsEnabled() {
        this.settings.isEnabled = this.isEnabled.checked;
        this.settings.save();
    }

    async onIsCombined() {
        this.settings.isCombined = this.isCombined.checked;
        this.settings.save();
    }

    async onShowPopoutButton() {
        this.settings.showPopoutButton = this.showPopoutButton.checked;
        this.settings.save();
    }

    async onGlobalSetListSort() {
        this.settings.config.setList = Array.from(this.globalSetList.children).map((it,idx)=>{
            const set = this.settings.config.setList[Number(it.getAttribute('data-order'))];
            it.setAttribute('data-order', String(idx));
            return set;
        });
        this.settings.save();
    }

    async onChatSetListSort() {
        this.settings.chatConfig.setList = Array.from(this.chatSetList.children).map((it,idx)=>{
            const set = this.settings.chatConfig.setList[Number(it.getAttribute('data-order'))];
            it.setAttribute('data-order', String(idx));
            return set;
        });
        this.settings.save();
    }

    updateOrder(list) {
        Array.from(list.children).forEach((it,idx)=>{
            it.setAttribute('data-order', idx);
        });
    }

    async onQrListSort() {
        this.currentQrSet.qrList = Array.from(this.qrList.querySelectorAll('.qr--set-item')).map((it,idx)=>{
            const qr = this.currentQrSet.qrList.find(qr=>qr.id == Number(it.getAttribute('data-id')));
            it.setAttribute('data-order', String(idx));
            return qr;
        });
        this.currentQrSet.save();
    }

    async deleteQrSet() {
        const confirmed = await callPopup(`Are you sure you want to delete the Quick Reply Set "${this.currentQrSet.name}"?<br>This cannot be undone.`, 'confirm');
        if (confirmed) {
            await this.doDeleteQrSet(this.currentQrSet);
            this.rerender();
        }
    }
    async doDeleteQrSet(qrs) {
        await qrs.delete();
        //TODO (HACK) should just bubble up from QuickReplySet.delete() but that would require proper or at least more comples onDelete listeners
        for (let i = this.settings.config.setList.length - 1; i >= 0; i--) {
            if (this.settings.config.setList[i].set == qrs) {
                this.settings.config.setList.splice(i, 1);
            }
        }
        if (this.settings.chatConfig) {
            for (let i = this.settings.chatConfig.setList.length - 1; i >= 0; i--) {
                if (this.settings.chatConfig.setList[i].set == qrs) {
                    this.settings.chatConfig.setList.splice(i, 1);
                }
            }
        }
        this.settings.save();
    }

    async addQrSet() {
        const name = await callPopup('Quick Reply Set Name:', 'input');
        if (name && name.length > 0) {
            const oldQrs = QuickReplySet.get(name);
            if (oldQrs) {
                const replace = await callPopup(`A Quick Reply Set named "${name}" already exists.<br>Do you want to overwrite the existing Quick Reply Set?<br>The existing set will be deleted. This cannot be undone.`, 'confirm');
                if (replace) {
                    const idx = QuickReplySet.list.indexOf(oldQrs);
                    await this.doDeleteQrSet(oldQrs);
                    const qrs = new QuickReplySet();
                    qrs.name = name;
                    qrs.addQuickReply();
                    QuickReplySet.list.splice(idx, 0, qrs);
                    this.rerender();
                    this.currentSet.value = name;
                    this.onQrSetChange();
                    this.prepareGlobalSetList();
                    this.prepareChatSetList();
                }
            } else {
                const qrs = new QuickReplySet();
                qrs.name = name;
                qrs.addQuickReply();
                const idx = QuickReplySet.list.findIndex(it=>it.name.toLowerCase().localeCompare(name.toLowerCase()) == 1);
                if (idx > -1) {
                    QuickReplySet.list.splice(idx, 0, qrs);
                } else {
                    QuickReplySet.list.push(qrs);
                }
                const opt = document.createElement('option'); {
                    opt.value = qrs.name;
                    opt.textContent = qrs.name;
                    if (idx > -1) {
                        this.currentSet.children[idx].insertAdjacentElement('beforebegin', opt);
                    } else {
                        this.currentSet.append(opt);
                    }
                }
                this.currentSet.value = name;
                this.onQrSetChange();
                this.prepareGlobalSetList();
                this.prepareChatSetList();
            }
        }
    }

    async importQrSet(/**@type {FileList}*/files) {
        for (let i = 0; i < files.length; i++) {
            await this.importSingleQrSet(files.item(i));
        }
    }
    async importSingleQrSet(/**@type {File}*/file) {
        log('FILE', file);
        try {
            const text = await file.text();
            const props = JSON.parse(text);
            if (!Number.isInteger(props.version) || typeof props.name != 'string') {
                toastr.error(`The file "${file.name}" does not appear to be a valid quick reply set.`);
                warn(`The file "${file.name}" does not appear to be a valid quick reply set.`);
            } else {
                /**@type {QuickReplySet}*/
                const qrs = QuickReplySet.from(JSON.parse(JSON.stringify(props)));
                qrs.qrList = props.qrList.map(it=>QuickReply.from(it));
                qrs.init();
                const oldQrs = QuickReplySet.get(props.name);
                if (oldQrs) {
                    const replace = await callPopup(`A Quick Reply Set named "${qrs.name}" already exists.<br>Do you want to overwrite the existing Quick Reply Set?<br>The existing set will be deleted. This cannot be undone.`, 'confirm');
                    if (replace) {
                        const idx = QuickReplySet.list.indexOf(oldQrs);
                        await this.doDeleteQrSet(oldQrs);
                        QuickReplySet.list.splice(idx, 0, qrs);
                        await qrs.save();
                        this.rerender();
                        this.currentSet.value = qrs.name;
                        this.onQrSetChange();
                        this.prepareGlobalSetList();
                        this.prepareChatSetList();
                    }
                } else {
                    const idx = QuickReplySet.list.findIndex(it=>it.name.toLowerCase().localeCompare(qrs.name.toLowerCase()) == 1);
                    if (idx > -1) {
                        QuickReplySet.list.splice(idx, 0, qrs);
                    } else {
                        QuickReplySet.list.push(qrs);
                    }
                    await qrs.save();
                    const opt = document.createElement('option'); {
                        opt.value = qrs.name;
                        opt.textContent = qrs.name;
                        if (idx > -1) {
                            this.currentSet.children[idx].insertAdjacentElement('beforebegin', opt);
                        } else {
                            this.currentSet.append(opt);
                        }
                    }
                    this.currentSet.value = qrs.name;
                    this.onQrSetChange();
                    this.prepareGlobalSetList();
                    this.prepareChatSetList();
                }
            }
        } catch (ex) {
            warn(ex);
            toastr.error(`Failed to import "${file.name}":\n\n${ex.message}`);
        }
    }

    exportQrSet() {
        const blob = new Blob([JSON.stringify(this.currentQrSet)], { type:'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); {
            a.href = url;
            a.download = `${this.currentQrSet.name}.json`;
            a.click();
        }
        URL.revokeObjectURL(url);
    }

    selectQrSet(qrs) {
        this.currentSet.value = qrs.name;
        this.onQrSetChange();
    }
}



---
File: /src/AutoExecuteHandler.js
---

import { warn } from '../index.js';
// eslint-disable-next-line no-unused-vars
import { QuickReply } from './QuickReply.js';
// eslint-disable-next-line no-unused-vars
import { QuickReplySettings } from './QuickReplySettings.js';

export class AutoExecuteHandler {
    /**@type {QuickReplySettings}*/ settings;

    /**@type {Boolean[]}*/ preventAutoExecuteStack = [];




    constructor(/**@type {QuickReplySettings}*/settings) {
        this.settings = settings;
    }


    checkExecute() {
        return this.settings.isEnabled && !this.preventAutoExecuteStack.slice(-1)[0];
    }




    async performAutoExecute(/**@type {QuickReply[]}*/qrList) {
        for (const qr of qrList) {
            this.preventAutoExecuteStack.push(qr.preventAutoExecute);
            try {
                await qr.execute({ isAutoExecute:true });
            } catch (ex) {
                warn(ex);
            } finally {
                this.preventAutoExecuteStack.pop();
            }
        }
    }


    async handleStartup() {
        if (!this.checkExecute()) return;
        const qrList = [
            ...this.settings.config.setList.map(link=>link.set.qrList.filter(qr=>qr.executeOnStartup)).flat(),
            ...(this.settings.chatConfig?.setList?.map(link=>link.set.qrList.filter(qr=>qr.executeOnStartup))?.flat() ?? []),
        ];
        await this.performAutoExecute(qrList);
    }

    async handleUser() {
        if (!this.checkExecute()) return;
        const qrList = [
            ...this.settings.config.setList.map(link=>link.set.qrList.filter(qr=>qr.executeOnUser)).flat(),
            ...(this.settings.chatConfig?.setList?.map(link=>link.set.qrList.filter(qr=>qr.executeOnUser))?.flat() ?? []),
        ];
        await this.performAutoExecute(qrList);
    }

    async handleAi() {
        if (!this.checkExecute()) return;
        const qrList = [
            ...this.settings.config.setList.map(link=>link.set.qrList.filter(qr=>qr.executeOnAi)).flat(),
            ...(this.settings.chatConfig?.setList?.map(link=>link.set.qrList.filter(qr=>qr.executeOnAi))?.flat() ?? []),
        ];
        await this.performAutoExecute(qrList);
    }

    async handleChatChanged() {
        if (!this.checkExecute()) return;
        const qrList = [
            ...this.settings.config.setList.map(link=>link.set.qrList.filter(qr=>qr.executeOnChatChange)).flat(),
            ...(this.settings.chatConfig?.setList?.map(link=>link.set.qrList.filter(qr=>qr.executeOnChatChange))?.flat() ?? []),
        ];
        await this.performAutoExecute(qrList);
    }

    async handleGroupMemberDraft() {
        if (!this.checkExecute()) return;
        const qrList = [
            ...this.settings.config.setList.map(link=>link.set.qrList.filter(qr=>qr.executeOnGroupMemberDraft)).flat(),
            ...(this.settings.chatConfig?.setList?.map(link=>link.set.qrList.filter(qr=>qr.executeOnGroupMemberDraft))?.flat() ?? []),
        ];
        await this.performAutoExecute(qrList);
    }

    async handleNewChat() {
        if (!this.checkExecute()) return;
        const qrList = [
            ...this.settings.config.setList.map(link=>link.set.qrList.filter(qr=>qr.executeOnNewChat)).flat(),
            ...(this.settings.chatConfig?.setList?.map(link=>link.set.qrList.filter(qr=>qr.executeOnNewChat))?.flat() ?? []),
        ];
        await this.performAutoExecute(qrList);
    }

    /**
     * @param {any[]} entries Set of activated entries
     */
    async handleWIActivation(entries) {
        if (!this.checkExecute() || !Array.isArray(entries) || entries.length === 0) return;
        const automationIds = entries.map(entry => entry.automationId).filter(Boolean);
        if (automationIds.length === 0) return;

        const qrList = [
            ...this.settings.config.setList.map(link=>link.set.qrList.filter(qr=>qr.automationId && automationIds.includes(qr.automationId))).flat(),
            ...(this.settings.chatConfig?.setList?.map(link=>link.set.qrList.filter(qr=>qr.automationId && automationIds.includes(qr.automationId)))?.flat() ?? []),
        ];

        await this.performAutoExecute(qrList);
    }
}



---
File: /src/QuickReply.js
---

import { POPUP_RESULT, POPUP_TYPE, Popup } from '../../../popup.js';
import { setSlashCommandAutoComplete } from '../../../slash-commands.js';
import { SlashCommandAbortController } from '../../../slash-commands/SlashCommandAbortController.js';
import { SlashCommandBreakPoint } from '../../../slash-commands/SlashCommandBreakPoint.js';
import { SlashCommandClosure } from '../../../slash-commands/SlashCommandClosure.js';
import { SlashCommandClosureResult } from '../../../slash-commands/SlashCommandClosureResult.js';
import { SlashCommandDebugController } from '../../../slash-commands/SlashCommandDebugController.js';
import { SlashCommandExecutor } from '../../../slash-commands/SlashCommandExecutor.js';
import { SlashCommandParser } from '../../../slash-commands/SlashCommandParser.js';
import { SlashCommandParserError } from '../../../slash-commands/SlashCommandParserError.js';
import { SlashCommandScope } from '../../../slash-commands/SlashCommandScope.js';
import { debounce, delay, getSortableDelay, showFontAwesomePicker } from '../../../utils.js';
import { log, quickReplyApi, warn } from '../index.js';
import morphdom from '../lib/morphdom-esm.js';
import { QuickReplyContextLink } from './QuickReplyContextLink.js';
import { QuickReplySet } from './QuickReplySet.js';
import { ContextMenu } from './ui/ctx/ContextMenu.js';

export class QuickReply {
    /**
     * @param {{ id?: number; contextList?: any; }} props
     */
    static from(props) {
        props.contextList = (props.contextList ?? []).map((/** @type {any} */ it)=>QuickReplyContextLink.from(it));
        return Object.assign(new this(), props);
    }




    /**@type {number}*/ id;
    /**@type {string}*/ icon;
    /**@type {string}*/ label = '';
    /**@type {boolean}*/ showLabel = false;
    /**@type {string}*/ title = '';
    /**@type {string}*/ message = '';

    /**@type {QuickReplyContextLink[]}*/ contextList;

    /**@type {boolean}*/ preventAutoExecute = true;
    /**@type {boolean}*/ isHidden = false;
    /**@type {boolean}*/ executeOnStartup = false;
    /**@type {boolean}*/ executeOnUser = false;
    /**@type {boolean}*/ executeOnAi = false;
    /**@type {boolean}*/ executeOnChatChange = false;
    /**@type {boolean}*/ executeOnGroupMemberDraft = false;
    /**@type {boolean}*/ executeOnNewChat = false;
    /**@type {string}*/ automationId = '';

    /**@type {function}*/ onExecute;
    /**@type {(qr:QuickReply)=>AsyncGenerator<SlashCommandClosureResult|{closure:SlashCommandClosure, executor:SlashCommandExecutor|SlashCommandClosureResult}, SlashCommandClosureResult, boolean>}*/ onDebug;
    /**@type {function}*/ onDelete;
    /**@type {function}*/ onUpdate;
    /**@type {function}*/ onInsertBefore;
    /**@type {function}*/ onTransfer;


    /**@type {HTMLElement}*/ dom;
    /**@type {HTMLElement}*/ domIcon;
    /**@type {HTMLElement}*/ domLabel;
    /**@type {HTMLElement}*/ settingsDom;
    /**@type {HTMLElement}*/ settingsDomIcon;
    /**@type {HTMLInputElement}*/ settingsDomLabel;
    /**@type {HTMLTextAreaElement}*/ settingsDomMessage;

    /**@type {Popup}*/ editorPopup;
    /**@type {HTMLElement}*/ editorDom;

    /**@type {HTMLTextAreaElement}*/ editorMessage;
    /**@type {HTMLTextAreaElement}*/ editorMessageLabel;
    /**@type {HTMLElement}*/ editorSyntax;
    /**@type {HTMLElement}*/ editorExecuteBtn;
    /**@type {HTMLElement}*/ editorExecuteBtnPause;
    /**@type {HTMLElement}*/ editorExecuteBtnStop;
    /**@type {HTMLElement}*/ editorExecuteProgress;
    /**@type {HTMLElement}*/ editorExecuteErrors;
    /**@type {HTMLElement}*/ editorExecuteResult;
    /**@type {HTMLElement}*/ editorDebugState;
    /**@type {Promise}*/ editorExecutePromise;
    /**@type {boolean}*/ isExecuting;
    /**@type {SlashCommandAbortController}*/ abortController;
    /**@type {SlashCommandDebugController}*/ debugController;


    get hasContext() {
        return this.contextList && this.contextList.filter(it => it.set).length > 0;
    }




    unrender() {
        this.dom?.remove();
        this.dom = null;
    }
    updateRender() {
        if (!this.dom) return;
        this.dom.title = this.title || this.message;
        if (this.icon) {
            this.domIcon.classList.remove('qr--hidden');
            if (this.showLabel) this.domLabel.classList.remove('qr--hidden');
            else this.domLabel.classList.add('qr--hidden');
        } else {
            this.domIcon.classList.add('qr--hidden');
            this.domLabel.classList.remove('qr--hidden');
        }
        this.domLabel.textContent = this.label;
        this.dom.classList[this.hasContext ? 'add' : 'remove']('qr--hasCtx');
    }
    render() {
        this.unrender();
        if (!this.dom) {
            const root = document.createElement('div'); {
                this.dom = root;
                root.classList.add('qr--button');
                root.classList.add('menu_button');
                if (this.hasContext) {
                    root.classList.add('qr--hasCtx');
                }
                root.title = this.title || this.message;
                root.addEventListener('contextmenu', (evt) => {
                    log('contextmenu', this, this.hasContext);
                    if (this.hasContext) {
                        evt.preventDefault();
                        evt.stopPropagation();
                        const menu = new ContextMenu(this);
                        menu.show(evt);
                    }
                });
                root.addEventListener('click', (evt)=>{
                    if (evt.ctrlKey) {
                        this.showEditor();
                        return;
                    }
                    this.execute();
                });
                const icon = document.createElement('div'); {
                    this.domIcon = icon;
                    icon.classList.add('qr--button-icon');
                    icon.classList.add('fa-solid');
                    if (!this.icon) icon.classList.add('qr--hidden');
                    else icon.classList.add(this.icon);
                    root.append(icon);
                }
                const lbl = document.createElement('div'); {
                    this.domLabel = lbl;
                    lbl.classList.add('qr--button-label');
                    if (this.icon && !this.showLabel) lbl.classList.add('qr--hidden');
                    lbl.textContent = this.label;
                    root.append(lbl);
                }
                const expander = document.createElement('div'); {
                    expander.classList.add('qr--button-expander');
                    expander.textContent = '⋮';
                    expander.title = 'Open context menu';
                    expander.addEventListener('click', (evt) => {
                        evt.stopPropagation();
                        evt.preventDefault();
                        const menu = new ContextMenu(this);
                        menu.show(evt);
                    });
                    root.append(expander);
                }
            }
        }
        return this.dom;
    }




    renderSettings(idx) {
        if (!this.settingsDom) {
            const item = document.createElement('div'); {
                this.settingsDom = item;
                item.classList.add('qr--set-item');
                item.setAttribute('data-order', String(idx));
                item.setAttribute('data-id', String(this.id));
                const adder = document.createElement('div'); {
                    adder.classList.add('qr--set-itemAdder');
                    const actions = document.createElement('div'); {
                        actions.classList.add('qr--actions');
                        const addNew = document.createElement('div'); {
                            addNew.classList.add('qr--action');
                            addNew.classList.add('qr--add');
                            addNew.classList.add('menu_button');
                            addNew.classList.add('menu_button_icon');
                            addNew.classList.add('fa-solid');
                            addNew.classList.add('fa-plus');
                            addNew.title = 'Add quick reply';
                            addNew.addEventListener('click', ()=>this.onInsertBefore());
                            actions.append(addNew);
                        }
                        const paste = document.createElement('div'); {
                            paste.classList.add('qr--action');
                            paste.classList.add('qr--paste');
                            paste.classList.add('menu_button');
                            paste.classList.add('menu_button_icon');
                            paste.classList.add('fa-solid');
                            paste.classList.add('fa-paste');
                            paste.title = 'Add quick reply from clipboard';
                            paste.addEventListener('click', async()=>{
                                const text = await navigator.clipboard.readText();
                                this.onInsertBefore(text);
                            });
                            actions.append(paste);
                        }
                        const importFile = document.createElement('div'); {
                            importFile.classList.add('qr--action');
                            importFile.classList.add('qr--importFile');
                            importFile.classList.add('menu_button');
                            importFile.classList.add('menu_button_icon');
                            importFile.classList.add('fa-solid');
                            importFile.classList.add('fa-file-import');
                            importFile.title = 'Add quick reply from JSON file';
                            importFile.addEventListener('click', async()=>{
                                const inp = document.createElement('input'); {
                                    inp.type = 'file';
                                    inp.accept = '.json';
                                    inp.addEventListener('change', async()=>{
                                        if (inp.files.length > 0) {
                                            for (const file of inp.files) {
                                                const text = await file.text();
                                                this.onInsertBefore(text);
                                            }
                                        }
                                    });
                                    inp.click();
                                }
                            });
                            actions.append(importFile);
                        }
                        adder.append(actions);
                    }
                    item.append(adder);
                }
                const itemContent = document.createElement('div'); {
                    itemContent.classList.add('qr--content');
                    const drag = document.createElement('div'); {
                        drag.classList.add('drag-handle');
                        drag.classList.add('ui-sortable-handle');
                        drag.textContent = '☰';
                        itemContent.append(drag);
                    }
                    const lblContainer = document.createElement('div'); {
                        lblContainer.classList.add('qr--set-itemLabelContainer');
                        const icon = document.createElement('div'); {
                            this.settingsDomIcon = icon;
                            icon.title = 'Click to change icon';
                            icon.classList.add('qr--set-itemIcon');
                            icon.classList.add('menu_button');
                            icon.classList.add('fa-fw');
                            if (this.icon) {
                                icon.classList.add('fa-solid');
                                icon.classList.add(this.icon);
                            }
                            icon.addEventListener('click', async()=>{
                                let value = await showFontAwesomePicker();
                                this.updateIcon(value);
                            });
                            lblContainer.append(icon);
                        }
                        const lbl = document.createElement('input'); {
                            this.settingsDomLabel = lbl;
                            lbl.classList.add('qr--set-itemLabel');
                            lbl.classList.add('text_pole');
                            lbl.value = this.label;
                            lbl.addEventListener('input', ()=>this.updateLabel(lbl.value));
                            lblContainer.append(lbl);
                        }
                        itemContent.append(lblContainer);
                    }
                    item.append(itemContent);
                }
                const optContainer = document.createElement('div'); {
                    optContainer.classList.add('qr--set-optionsContainer');
                    const opt = document.createElement('div'); {
                        opt.classList.add('qr--action');
                        opt.classList.add('menu_button');
                        opt.classList.add('fa-fw');
                        opt.classList.add('fa-solid');
                        opt.textContent = '⁝';
                        opt.title = 'Additional options:\n - large editor\n - context menu\n - auto-execution\n - tooltip';
                        opt.addEventListener('click', ()=>this.showEditor());
                        optContainer.append(opt);
                    }
                    itemContent.append(optContainer);
                }
                const mes = document.createElement('textarea'); {
                    this.settingsDomMessage = mes;
                    mes.id = `qr--set--item${this.id}`;
                    mes.classList.add('qr--set-itemMessage');
                    mes.value = this.message;
                    //HACK need to use jQuery to catch the triggered event from the expanded editor
                    $(mes).on('input', ()=>this.updateMessage(mes.value));
                    itemContent.append(mes);
                }
                const actions = document.createElement('div'); {
                    actions.classList.add('qr--actions');
                    const move = document.createElement('div'); {
                        move.classList.add('qr--action');
                        move.classList.add('menu_button');
                        move.classList.add('fa-fw');
                        move.classList.add('fa-solid');
                        move.classList.add('fa-truck-arrow-right');
                        move.title = 'Move quick reply to other set';
                        move.addEventListener('click', ()=>this.onTransfer(this));
                        actions.append(move);
                    }
                    const copy = document.createElement('div'); {
                        copy.classList.add('qr--action');
                        copy.classList.add('menu_button');
                        copy.classList.add('fa-fw');
                        copy.classList.add('fa-solid');
                        copy.classList.add('fa-copy');
                        copy.title = 'Copy quick reply to clipboard';
                        copy.addEventListener('click', async()=>{
                            await navigator.clipboard.writeText(JSON.stringify(this));
                            copy.classList.add('qr--success');
                            await delay(3010);
                            copy.classList.remove('qr--success');
                        });
                        actions.append(copy);
                    }
                    const cut = document.createElement('div'); {
                        cut.classList.add('qr--action');
                        cut.classList.add('menu_button');
                        cut.classList.add('fa-fw');
                        cut.classList.add('fa-solid');
                        cut.classList.add('fa-cut');
                        cut.title = 'Cut quick reply to clipboard (copy and remove)';
                        cut.addEventListener('click', async()=>{
                            await navigator.clipboard.writeText(JSON.stringify(this));
                            this.delete();
                        });
                        actions.append(cut);
                    }
                    const exp = document.createElement('div'); {
                        exp.classList.add('qr--action');
                        exp.classList.add('menu_button');
                        exp.classList.add('fa-fw');
                        exp.classList.add('fa-solid');
                        exp.classList.add('fa-file-export');
                        exp.title = 'Export quick reply as file';
                        exp.addEventListener('click', ()=>{
                            const blob = new Blob([JSON.stringify(this)], { type:'text' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a'); {
                                a.href = url;
                                a.download = `${this.label}.qr.json`;
                                a.click();
                            }
                        });
                        actions.append(exp);
                    }
                    const del = document.createElement('div'); {
                        del.classList.add('qr--action');
                        del.classList.add('menu_button');
                        del.classList.add('fa-fw');
                        del.classList.add('fa-solid');
                        del.classList.add('fa-trash-can');
                        del.classList.add('redWarningBG');
                        del.title = 'Remove Quick Reply\n---\nShift+Click to skip confirmation';
                        del.addEventListener('click', async(evt)=>{
                            if (!evt.shiftKey) {
                                const result = await Popup.show.confirm(
                                    'Remove Quick Reply',
                                    'Are you sure you want to remove this Quick Reply?',
                                );
                                if (result != POPUP_RESULT.AFFIRMATIVE) {
                                    return;
                                }
                            }
                            this.delete();
                        });
                        actions.append(del);
                    }
                    itemContent.append(actions);
                }
            }
        }
        return this.settingsDom;
    }
    unrenderSettings() {
        this.settingsDom?.remove();
    }

    async showEditor() {
        const response = await fetch('/scripts/extensions/quick-reply/html/qrEditor.html', { cache: 'no-store' });
        if (response.ok) {
            this.template = document.createRange().createContextualFragment(await response.text()).querySelector('#qr--modalEditor');
            /**@type {HTMLElement} */
            // @ts-ignore
            const dom = this.template.cloneNode(true);
            this.editorDom = dom;
            this.editorPopup = new Popup(dom, POPUP_TYPE.TEXT, undefined, { okButton: 'OK', wide: true, large: true, rows: 1 });
            const popupResult = this.editorPopup.show();

            // basics
            /**@type {HTMLElement}*/
            const icon = dom.querySelector('#qr--modal-icon');
            if (this.icon) {
                icon.classList.add('fa-solid');
                icon.classList.add(this.icon);
            }
            else {
                icon.textContent = '…';
            }
            icon.addEventListener('click', async()=>{
                let value = await showFontAwesomePicker();
                if (value === null) return;
                if (this.icon) icon.classList.remove(this.icon);
                if (value == '') {
                    icon.classList.remove('fa-solid');
                    icon.textContent = '…';
                } else {
                    icon.textContent = '';
                    icon.classList.add('fa-solid');
                    icon.classList.add(value);
                }
                this.updateIcon(value);
            });
            /**@type {HTMLInputElement}*/
            const showLabel = dom.querySelector('#qr--modal-showLabel');
            showLabel.checked = this.showLabel;
            showLabel.addEventListener('click', ()=>{
                this.updateShowLabel(showLabel.checked);
            });
            /**@type {HTMLInputElement}*/
            const label = dom.querySelector('#qr--modal-label');
            label.value = this.label;
            label.addEventListener('input', ()=>{
                this.updateLabel(label.value);
            });
            let switcherList;
            dom.querySelector('#qr--modal-switcher').addEventListener('click', (evt)=>{
                if (switcherList) {
                    switcherList.remove();
                    switcherList = null;
                    return;
                }
                const list = document.createElement('ul'); {
                    switcherList = list;
                    list.classList.add('qr--modal-switcherList');
                    const makeList = (qrs)=>{
                        const setItem = document.createElement('li'); {
                            setItem.classList.add('qr--modal-switcherItem');
                            setItem.addEventListener('click', ()=>{
                                list.innerHTML = '';
                                for (const qrs of quickReplyApi.listSets()) {
                                    const item = document.createElement('li'); {
                                        item.classList.add('qr--modal-switcherItem');
                                        item.addEventListener('click', ()=>{
                                            list.innerHTML = '';
                                            makeList(quickReplyApi.getSetByName(qrs));
                                        });
                                        const lbl = document.createElement('div'); {
                                            lbl.classList.add('qr--label');
                                            lbl.textContent = qrs;
                                            item.append(lbl);
                                        }
                                        list.append(item);
                                    }
                                }
                            });
                            const lbl = document.createElement('div'); {
                                lbl.classList.add('qr--label');
                                const icon = document.createElement('i'); {
                                    icon.classList.add('fa-solid');
                                    icon.classList.add('fa-arrow-alt-circle-right');
                                    icon.classList.add('menu_button');
                                    lbl.append(icon);
                                }
                                const text = document.createElement('span'); {
                                    text.textContent = 'Switch QR Sets...';
                                    lbl.append(text);
                                }
                                setItem.append(lbl);
                            }
                            list.append(setItem);
                        }
                        const addItem = document.createElement('li'); {
                            addItem.classList.add('qr--modal-switcherItem');
                            addItem.addEventListener('click', ()=>{
                                const qr = quickReplyApi.getSetByQr(this).addQuickReply();
                                this.editorPopup.completeAffirmative();
                                qr.showEditor();
                            });
                            const lbl = document.createElement('div'); {
                                lbl.classList.add('qr--label');
                                const icon = document.createElement('i'); {
                                    icon.classList.add('fa-solid');
                                    icon.classList.add('fa-plus');
                                    icon.classList.add('menu_button');
                                    lbl.append(icon);
                                }
                                const text = document.createElement('span'); {
                                    text.textContent = 'Add QR';
                                    lbl.append(text);
                                }
                                addItem.append(lbl);
                            }
                            list.append(addItem);
                        }
                        for (const qr of qrs.qrList.toSorted((a,b)=>a.label.toLowerCase().localeCompare(b.label.toLowerCase()))) {
                            const item = document.createElement('li'); {
                                item.classList.add('qr--modal-switcherItem');
                                if (qr == this) item.classList.add('qr--current');
                                else item.addEventListener('click', ()=>{
                                    this.editorPopup.completeAffirmative();
                                    qr.showEditor();
                                });
                                const lbl = document.createElement('div'); {
                                    lbl.classList.add('qr--label');
                                    lbl.textContent = qr.label;
                                    item.append(lbl);
                                }
                                const id = document.createElement('div'); {
                                    id.classList.add('qr--id');
                                    id.textContent = qr.id.toString();
                                    item.append(id);
                                }
                                const mes = document.createElement('div'); {
                                    mes.classList.add('qr--message');
                                    mes.textContent = qr.message;
                                    item.append(mes);
                                }
                                list.append(item);
                            }
                        }
                    };
                    makeList(quickReplyApi.getSetByQr(this));
                }
                label.parentElement.append(list);
            });
            /**@type {HTMLInputElement}*/
            const title = dom.querySelector('#qr--modal-title');
            title.value = this.title;
            title.addEventListener('input', () => {
                this.updateTitle(title.value);
            });
            /**@type {HTMLElement}*/
            const messageSyntaxInner = dom.querySelector('#qr--modal-messageSyntaxInner');
            this.editorSyntax = messageSyntaxInner;
            /**@type {HTMLInputElement}*/
            const wrap = dom.querySelector('#qr--modal-wrap');
            wrap.checked = JSON.parse(localStorage.getItem('qr--wrap') ?? 'false');
            wrap.addEventListener('click', () => {
                localStorage.setItem('qr--wrap', JSON.stringify(wrap.checked));
                updateWrap();
            });
            const updateWrap = () => {
                if (wrap.checked) {
                    message.style.whiteSpace = 'pre-wrap';
                    messageSyntaxInner.style.whiteSpace = 'pre-wrap';
                    if (this.clone) {
                        this.clone.style.whiteSpace = 'pre-wrap';
                    }
                } else {
                    message.style.whiteSpace = 'pre';
                    messageSyntaxInner.style.whiteSpace = 'pre';
                    if (this.clone) {
                        this.clone.style.whiteSpace = 'pre';
                    }
                }
                updateScrollDebounced();
            };
            const updateScroll = (evt) => {
                let left = message.scrollLeft;
                let top = message.scrollTop;
                if (evt) {
                    evt.preventDefault();
                    left = message.scrollLeft + evt.deltaX;
                    top = message.scrollTop + evt.deltaY;
                    message.scrollTo({
                        behavior: 'instant',
                        left,
                        top,
                    });
                }
                messageSyntaxInner.scrollTo({
                    behavior: 'instant',
                    left,
                    top,
                });
            };
            const updateScrollDebounced = updateScroll;
            const updateSyntaxEnabled = ()=>{
                if (syntax.checked) {
                    dom.querySelector('#qr--modal-messageHolder').classList.remove('qr--noSyntax');
                } else {
                    dom.querySelector('#qr--modal-messageHolder').classList.add('qr--noSyntax');
                }
            };
            /**@type {HTMLInputElement}*/
            const tabSize = dom.querySelector('#qr--modal-tabSize');
            tabSize.value = JSON.parse(localStorage.getItem('qr--tabSize') ?? '4');
            const updateTabSize = () => {
                message.style.tabSize = tabSize.value;
                messageSyntaxInner.style.tabSize = tabSize.value;
                updateScrollDebounced();
            };
            tabSize.addEventListener('change', () => {
                localStorage.setItem('qr--tabSize', JSON.stringify(Number(tabSize.value)));
                updateTabSize();
            });
            /**@type {HTMLInputElement}*/
            const executeShortcut = dom.querySelector('#qr--modal-executeShortcut');
            executeShortcut.checked = JSON.parse(localStorage.getItem('qr--executeShortcut') ?? 'true');
            executeShortcut.addEventListener('click', () => {
                localStorage.setItem('qr--executeShortcut', JSON.stringify(executeShortcut.checked));
            });
            /**@type {HTMLInputElement}*/
            const syntax = dom.querySelector('#qr--modal-syntax');
            syntax.checked = JSON.parse(localStorage.getItem('qr--syntax') ?? 'true');
            syntax.addEventListener('click', () => {
                localStorage.setItem('qr--syntax', JSON.stringify(syntax.checked));
                updateSyntaxEnabled();
            });
            if (navigator.keyboard) {
                navigator.keyboard.getLayoutMap().then(it=>dom.querySelector('#qr--modal-commentKey').textContent = it.get('Backslash'));
            } else {
                dom.querySelector('#qr--modal-commentKey').closest('small').remove();
            }
            this.editorMessageLabel = dom.querySelector('label[for="qr--modal-message"]');
            /**@type {HTMLTextAreaElement}*/
            const message = dom.querySelector('#qr--modal-message');
            this.editorMessage = message;
            message.value = this.message;
            const updateMessageDebounced = debounce((value)=>this.updateMessage(value), 10);
            message.addEventListener('input', () => {
                updateMessageDebounced(message.value);
                updateScrollDebounced();
            }, { passive:true });
            const getLineStart = ()=>{
                const start = message.selectionStart;
                const end = message.selectionEnd;
                let lineStart;
                if (start == 0 || message.value[start - 1] == '\n') {
                    // cursor is already at beginning of line
                    // -> keep start
                    lineStart = start;
                } else {
                    // cursor is at end of line or somewhere in the line
                    // -> find last newline before cursor and start after that
                    lineStart = message.value.lastIndexOf('\n', start - 1) + 1;
                }
                return lineStart;
            };
            message.addEventListener('keydown', async(evt) => {
                if (this.isExecuting) return;
                if (evt.key == 'Tab' && !evt.shiftKey && !evt.ctrlKey && !evt.altKey) {
                    // increase indent
                    evt.preventDefault();
                    const start = message.selectionStart;
                    const end = message.selectionEnd;
                    if (end - start > 0 && message.value.substring(start, end).includes('\n')) {
                        evt.stopImmediatePropagation();
                        evt.stopPropagation();
                        const lineStart = getLineStart();
                        message.selectionStart = lineStart;
                        const affectedLines = message.value.substring(lineStart, end).split('\n');
                        // document.execCommand is deprecated (and potentially buggy in some browsers) but the only way to retain undo-history
                        document.execCommand('insertText', false, `\t${affectedLines.join('\n\t')}`);
                        message.selectionStart = start + 1;
                        message.selectionEnd = end + affectedLines.length;
                        message.dispatchEvent(new Event('input', { bubbles:true }));
                    } else if (!(ac.isReplaceable && ac.isActive)) {
                        evt.stopImmediatePropagation();
                        evt.stopPropagation();
                        // document.execCommand is deprecated (and potentially buggy in some browsers) but the only way to retain undo-history
                        document.execCommand('insertText', false, '\t');
                        message.dispatchEvent(new Event('input', { bubbles:true }));
                    }
                } else if (evt.key == 'Tab' && evt.shiftKey && !evt.ctrlKey && !evt.altKey) {
                    // decrease indent
                    evt.preventDefault();
                    evt.stopImmediatePropagation();
                    evt.stopPropagation();
                    const start = message.selectionStart;
                    const end = message.selectionEnd;
                    const lineStart = getLineStart();
                    message.selectionStart = lineStart;
                    const affectedLines = message.value.substring(lineStart, end).split('\n');
                    const newText = affectedLines.map(it=>it.replace(/^\t/, '')).join('\n');
                    const delta = affectedLines.join('\n').length - newText.length;
                    // document.execCommand is deprecated (and potentially buggy in some browsers) but the only way to retain undo-history
                    if (delta > 0) {
                        if (newText == '') {
                            document.execCommand('delete', false);
                        } else {
                            document.execCommand('insertText', false, newText);
                        }
                        message.selectionStart = start - (affectedLines[0].startsWith('\t') ? 1 : 0);
                        message.selectionEnd = end - delta;
                        message.dispatchEvent(new Event('input', { bubbles:true }));
                    } else {
                        message.selectionStart = start;
                    }
                } else if (evt.key == 'Enter' && !evt.ctrlKey && !evt.shiftKey && !evt.altKey && !(ac.isReplaceable && ac.isActive)) {
                    // new line, keep indent
                    const start = message.selectionStart;
                    const end = message.selectionEnd;
                    let lineStart = getLineStart();
                    const indent = /^([^\S\n]*)/.exec(message.value.slice(lineStart))[1] ?? '';
                    if (indent.length) {
                        evt.stopImmediatePropagation();
                        evt.stopPropagation();
                        evt.preventDefault();
                        // document.execCommand is deprecated (and potentially buggy in some browsers) but the only way to retain undo-history
                        document.execCommand('insertText', false, `\n${indent}`);
                        message.selectionStart = start + 1 + indent.length;
                        message.selectionEnd  = message.selectionStart;
                        message.dispatchEvent(new Event('input', { bubbles:true }));
                    }
                } else if (evt.key == 'Enter' && evt.ctrlKey && !evt.shiftKey && !evt.altKey) {
                    if (executeShortcut.checked) {
                        // execute QR
                        evt.stopImmediatePropagation();
                        evt.stopPropagation();
                        evt.preventDefault();
                        const selectionStart = message.selectionStart;
                        const selectionEnd = message.selectionEnd;
                        message.blur();
                        await this.executeFromEditor();
                        if (document.activeElement != message) {
                            message.focus();
                            message.selectionStart = selectionStart;
                            message.selectionEnd = selectionEnd;
                        }
                    }
                } else if (evt.key == 'F9' && !evt.ctrlKey && !evt.shiftKey && !evt.altKey) {
                    // toggle breakpoint
                    evt.stopImmediatePropagation();
                    evt.stopPropagation();
                    evt.preventDefault();
                    preBreakPointStart = message.selectionStart;
                    preBreakPointEnd = message.selectionEnd;
                    toggleBreakpoint();
                } else if (evt.code == 'Backslash' && evt.ctrlKey && !evt.shiftKey && !evt.altKey) {
                    // toggle block comment
                    // (evt.code will use the same physical key on the keyboard across different keyboard layouts)
                    evt.stopImmediatePropagation();
                    evt.stopPropagation();
                    evt.preventDefault();
                    // check if we are inside a comment -> uncomment
                    const parser = new SlashCommandParser();
                    parser.parse(message.value, false);
                    const start = message.selectionStart;
                    const end = message.selectionEnd;
                    const comment = parser.commandIndex.findLast(it=>it.name == '*' && (it.start <= start && it.end >= start || it.start <= end && it.end >= end));
                    if (comment) {
                        // uncomment
                        let content = message.value.slice(comment.start + 1, comment.end - 1);
                        let len = content.length;
                        content = content.replace(/^ /, '');
                        const offsetStart = len - content.length;
                        len = content.length;
                        content = content.replace(/ $/, '');
                        const offsetEnd = len - content.length;
                        message.selectionStart = comment.start - 1;
                        message.selectionEnd = comment.end + 1;
                        // document.execCommand is deprecated (and potentially buggy in some browsers) but the only way to retain undo-history
                        document.execCommand('insertText', false, content);
                        message.selectionStart = start - (start >= comment.start ? 2 + offsetStart : 0);
                        message.selectionEnd = end - 2 - offsetStart - (end >= comment.end ? 2 + offsetEnd : 0);
                    } else {
                        // comment
                        const lineStart = getLineStart();
                        const lineEnd = message.value.indexOf('\n', end);
                        message.selectionStart = lineStart;
                        message.selectionEnd = lineEnd;
                        // document.execCommand is deprecated (and potentially buggy in some browsers) but the only way to retain undo-history
                        document.execCommand('insertText', false, `/* ${message.value.slice(lineStart, lineEnd)} *|`);
                        message.selectionStart = start + 3;
                        message.selectionEnd = end + 3;
                    }
                    message.dispatchEvent(new Event('input', { bubbles:true }));
                }
            });
            const ac = await setSlashCommandAutoComplete(message, true);
            message.addEventListener('wheel', (evt)=>{
                updateScrollDebounced(evt);
            });
            message.addEventListener('scroll', (evt)=>{
                updateScrollDebounced();
            });
            let preBreakPointStart;
            let preBreakPointEnd;
            /**
             * @param {SlashCommandBreakPoint} bp
             */
            const removeBreakpoint = (bp)=>{
                // start at -1 because "/" is not included in start-end
                let start = bp.start - 1;
                // step left until forward slash "/"
                while (message.value[start] != '/') start--;
                // step left while whitespace (except newline) before start
                while (/[^\S\n]/.test(message.value[start - 1])) start--;
                // if newline before indent, include the newline for removal
                if (message.value[start - 1] == '\n') start--;
                let end = bp.end;
                // step right while whitespace
                while (/\s/.test(message.value[end])) end++;
                // if pipe after whitepace, include pipe for removal
                if (message.value[end] == '|') end++;
                message.selectionStart = start;
                message.selectionEnd = end;
                // document.execCommand is deprecated (and potentially buggy in some browsers) but the only way to retain undo-history
                document.execCommand('insertText', false, '');
                message.dispatchEvent(new Event('input', { bubbles:true }));
                let postStart = preBreakPointStart;
                let postEnd = preBreakPointEnd;
                // set caret back to where it was
                if (preBreakPointStart <= start) {
                    // selection start was before breakpoint: do nothing
                } else if (preBreakPointStart > start && preBreakPointEnd < end) {
                    // selection start was inside breakpoint: move to index before breakpoint
                    postStart = start;
                } else if (preBreakPointStart >= end) {
                    // selection start was behind breakpoint: move back by length of removed string
                    postStart = preBreakPointStart - (end - start);
                }
                if (preBreakPointEnd <= start) {
                    // do nothing
                } else if (preBreakPointEnd > start && preBreakPointEnd < end) {
                    // selection end was inside breakpoint: move to index before breakpoint
                    postEnd = start;
                } else if (preBreakPointEnd >= end) {
                    // selection end was behind breakpoint: move back by length of removed string
                    postEnd = preBreakPointEnd - (end - start);
                }
                return { start:postStart, end:postEnd };
            };
            /**
             * @param {SlashCommandExecutor} cmd
             */
            const addBreakpoint = (cmd)=>{
                // start at -1 because "/" is not included in start-end
                let start = cmd.start - 1;
                let indent = '';
                // step left until forward slash "/"
                while (message.value[start] != '/') start--;
                // step left while whitespace (except newline) before start, collect the whitespace to help build indentation
                while (/[^\S\n]/.test(message.value[start - 1])) {
                    start--;
                    indent += message.value[start];
                }
                // if newline before indent, include the newline
                if (message.value[start - 1] == '\n') {
                    start--;
                    indent = `\n${indent}`;
                }
                const breakpointText = `${indent}/breakpoint |`;
                message.selectionStart = start;
                message.selectionEnd = start;
                // document.execCommand is deprecated (and potentially buggy in some browsers) but the only way to retain undo-history
                document.execCommand('insertText', false, breakpointText);
                message.dispatchEvent(new Event('input', { bubbles:true }));
                return breakpointText.length;
            };
            const toggleBreakpoint = ()=>{
                const idx = message.selectionStart;
                let postStart = preBreakPointStart;
                let postEnd = preBreakPointEnd;
                const parser = new SlashCommandParser();
                parser.parse(message.value, false);
                const cmdIdx = parser.commandIndex.findLastIndex(it=>it.start <= idx);
                if (cmdIdx > -1) {
                    const cmd = parser.commandIndex[cmdIdx];
                    if (cmd instanceof SlashCommandBreakPoint) {
                        const bp = cmd;
                        const { start, end } = removeBreakpoint(bp);
                        postStart = start;
                        postEnd = end;
                    } else if (parser.commandIndex[cmdIdx - 1] instanceof SlashCommandBreakPoint) {
                        const bp = parser.commandIndex[cmdIdx - 1];
                        const { start, end } = removeBreakpoint(bp);
                        postStart = start;
                        postEnd = end;
                    } else {
                        const len = addBreakpoint(cmd);
                        postStart += len;
                        postEnd += len;
                    }
                    message.selectionStart = postStart;
                    message.selectionEnd = postEnd;
                }
            };
            message.addEventListener('pointerdown', (evt)=>{
                if (!evt.ctrlKey || !evt.altKey) return;
                preBreakPointStart = message.selectionStart;
                preBreakPointEnd = message.selectionEnd;
            });
            message.addEventListener('pointerup', async(evt)=>{
                if (!evt.ctrlKey || !evt.altKey || message.selectionStart != message.selectionEnd) return;
                toggleBreakpoint();
            });
            /** @type {any} */
            const resizeListener = debounce((evt) => {
                updateScrollDebounced(evt);
                if (document.activeElement == message) {
                    message.blur();
                    message.focus();
                }
            });
            window.addEventListener('resize', resizeListener);
            updateSyntaxEnabled();
            const updateSyntax = ()=>{
                if (messageSyntaxInner && syntax.checked) {
                    morphdom(
                        messageSyntaxInner,
                        `<div>${hljs.highlight(`${message.value}${message.value.slice(-1) == '\n' ? ' ' : ''}`, { language:'stscript', ignoreIllegals:true })?.value}</div>`,
                        { childrenOnly: true },
                    );
                    updateScrollDebounced();
                }
            };
            let lastSyntaxUpdate = 0;
            const fpsTime = 1000 / 30;
            let lastMessageValue = null;
            let wasSyntax = null;
            const updateSyntaxLoop = ()=>{
                const now = Date.now();
                // fps limit
                if (now - lastSyntaxUpdate < fpsTime) return requestAnimationFrame(updateSyntaxLoop);
                // elements don't exist (yet?)
                if (!messageSyntaxInner || !message)  return requestAnimationFrame(updateSyntaxLoop);
                // elements no longer part of the document
                if (!messageSyntaxInner.closest('body')) return;
                // debugger is running
                if (this.isExecuting) {
                    lastMessageValue = null;
                    return requestAnimationFrame(updateSyntaxLoop);
                }
                // value hasn't changed
                if (wasSyntax == syntax.checked && lastMessageValue == message.value) return requestAnimationFrame(updateSyntaxLoop);
                wasSyntax = syntax.checked;
                lastSyntaxUpdate = now;
                lastMessageValue = message.value;
                updateSyntax();
                requestAnimationFrame(updateSyntaxLoop);
            };
            requestAnimationFrame(()=>updateSyntaxLoop());
            message.style.setProperty('text-shadow', 'none', 'important');
            updateWrap();
            updateTabSize();

            // context menu
            /**@type {HTMLTemplateElement}*/
            const tpl = dom.querySelector('#qr--ctxItem');
            const linkList = dom.querySelector('#qr--ctxEditor');
            const fillQrSetSelect = (/**@type {HTMLSelectElement}*/select, /**@type {QuickReplyContextLink}*/ link) => {
                [{ name: 'Select a QR set' }, ...QuickReplySet.list.toSorted((a,b)=>a.name.toLowerCase().localeCompare(b.name.toLowerCase()))].forEach(qrs => {
                    const opt = document.createElement('option'); {
                        opt.value = qrs.name;
                        opt.textContent = qrs.name;
                        opt.selected = qrs.name == link.set?.name;
                        select.append(opt);
                    }
                });
            };
            const addCtxItem = (/**@type {QuickReplyContextLink}*/link, /**@type {number}*/idx) => {
                /**@type {HTMLElement} */
                // @ts-ignore
                const itemDom = tpl.content.querySelector('.qr--ctxItem').cloneNode(true); {
                    itemDom.setAttribute('data-order', String(idx));

                    /**@type {HTMLSelectElement} */
                    const select = itemDom.querySelector('.qr--set');
                    fillQrSetSelect(select, link);
                    select.addEventListener('change', () => {
                        link.set = QuickReplySet.get(select.value);
                        this.updateContext();
                    });

                    /**@type {HTMLInputElement} */
                    const chain = itemDom.querySelector('.qr--isChained');
                    chain.checked = link.isChained;
                    chain.addEventListener('click', () => {
                        link.isChained = chain.checked;
                        this.updateContext();
                    });

                    itemDom.querySelector('.qr--delete').addEventListener('click', () => {
                        itemDom.remove();
                        this.contextList.splice(this.contextList.indexOf(link), 1);
                        this.updateContext();
                    });

                    linkList.append(itemDom);
                }
            };
            [...this.contextList].forEach((link, idx) => addCtxItem(link, idx));
            dom.querySelector('#qr--ctxAdd').addEventListener('click', () => {
                const link = new QuickReplyContextLink();
                this.contextList.push(link);
                addCtxItem(link, this.contextList.length - 1);
            });
            const onContextSort = () => {
                this.contextList = Array.from(linkList.querySelectorAll('.qr--ctxItem')).map((it,idx) => {
                    const link = this.contextList[Number(it.getAttribute('data-order'))];
                    it.setAttribute('data-order', String(idx));
                    return link;
                });
                this.updateContext();
            };
            // @ts-ignore
            $(linkList).sortable({
                delay: getSortableDelay(),
                stop: () => onContextSort(),
            });

            // auto-exec
            /**@type {HTMLInputElement}*/
            const preventAutoExecute = dom.querySelector('#qr--preventAutoExecute');
            preventAutoExecute.checked = this.preventAutoExecute;
            preventAutoExecute.addEventListener('click', ()=>{
                this.preventAutoExecute = preventAutoExecute.checked;
                this.updateContext();
            });
            /**@type {HTMLInputElement}*/
            const isHidden = dom.querySelector('#qr--isHidden');
            isHidden.checked = this.isHidden;
            isHidden.addEventListener('click', ()=>{
                this.isHidden = isHidden.checked;
                this.updateContext();
            });
            /**@type {HTMLInputElement}*/
            const executeOnStartup = dom.querySelector('#qr--executeOnStartup');
            executeOnStartup.checked = this.executeOnStartup;
            executeOnStartup.addEventListener('click', ()=>{
                this.executeOnStartup = executeOnStartup.checked;
                this.updateContext();
            });
            /**@type {HTMLInputElement}*/
            const executeOnUser = dom.querySelector('#qr--executeOnUser');
            executeOnUser.checked = this.executeOnUser;
            executeOnUser.addEventListener('click', ()=>{
                this.executeOnUser = executeOnUser.checked;
                this.updateContext();
            });
            /**@type {HTMLInputElement}*/
            const executeOnAi = dom.querySelector('#qr--executeOnAi');
            executeOnAi.checked = this.executeOnAi;
            executeOnAi.addEventListener('click', ()=>{
                this.executeOnAi = executeOnAi.checked;
                this.updateContext();
            });
            /**@type {HTMLInputElement}*/
            const executeOnChatChange = dom.querySelector('#qr--executeOnChatChange');
            executeOnChatChange.checked = this.executeOnChatChange;
            executeOnChatChange.addEventListener('click', ()=>{
                this.executeOnChatChange = executeOnChatChange.checked;
                this.updateContext();
            });
            /**@type {HTMLInputElement}*/
            const executeOnGroupMemberDraft = dom.querySelector('#qr--executeOnGroupMemberDraft');
            executeOnGroupMemberDraft.checked = this.executeOnGroupMemberDraft;
            executeOnGroupMemberDraft.addEventListener('click', ()=>{
                this.executeOnGroupMemberDraft = executeOnGroupMemberDraft.checked;
                this.updateContext();
            });
            /**@type {HTMLInputElement}*/
            const executeOnNewChat = dom.querySelector('#qr--executeOnNewChat');
            executeOnNewChat.checked = this.executeOnNewChat;
            executeOnNewChat.addEventListener('click', ()=>{
                this.executeOnNewChat = executeOnNewChat.checked;
                this.updateContext();
            });
            /**@type {HTMLInputElement}*/
            const automationId = dom.querySelector('#qr--automationId');
            automationId.value = this.automationId;
            automationId.addEventListener('input', () => {
                this.automationId = automationId.value;
                this.updateContext();
            });

            /**@type {HTMLElement}*/
            const executeProgress = dom.querySelector('#qr--modal-executeProgress');
            this.editorExecuteProgress = executeProgress;
            /**@type {HTMLElement}*/
            const executeErrors = dom.querySelector('#qr--modal-executeErrors');
            this.editorExecuteErrors = executeErrors;
            /**@type {HTMLElement}*/
            const executeResult = dom.querySelector('#qr--modal-executeResult');
            this.editorExecuteResult = executeResult;
            /**@type {HTMLElement}*/
            const debugState = dom.querySelector('#qr--modal-debugState');
            this.editorDebugState = debugState;
            /**@type {HTMLElement}*/
            const executeBtn = dom.querySelector('#qr--modal-execute');
            this.editorExecuteBtn = executeBtn;
            executeBtn.addEventListener('click', async()=>{
                await this.executeFromEditor();
            });
            /**@type {HTMLElement}*/
            const executeBtnPause = dom.querySelector('#qr--modal-pause');
            this.editorExecuteBtnPause = executeBtnPause;
            executeBtnPause.addEventListener('click', async()=>{
                if (this.abortController) {
                    if (this.abortController.signal.paused) {
                        this.abortController.continue('Continue button clicked');
                        this.editorExecuteProgress.classList.remove('qr--paused');
                    } else {
                        this.abortController.pause('Pause button clicked');
                        this.editorExecuteProgress.classList.add('qr--paused');
                    }
                }
            });
            /**@type {HTMLElement}*/
            const executeBtnStop = dom.querySelector('#qr--modal-stop');
            this.editorExecuteBtnStop = executeBtnStop;
            executeBtnStop.addEventListener('click', async()=>{
                this.abortController?.abort('Stop button clicked');
            });

            /**@type {HTMLTextAreaElement} */
            const inputOg = document.querySelector('#send_textarea');
            const inputMirror = dom.querySelector('#qr--modal-send_textarea');
            inputMirror.value = inputOg.value;
            const inputOgMo = new MutationObserver(muts=>{
                if (muts.find(it=>[...it.removedNodes].includes(inputMirror) || [...it.removedNodes].find(n=>n.contains(inputMirror)))) {
                    inputOg.removeEventListener('input', inputOgListener);
                }
            });
            inputOgMo.observe(document.body, { childList:true });
            const inputOgListener = ()=>{
                inputMirror.value = inputOg.value;
            };
            inputOg.addEventListener('input', inputOgListener);
            inputMirror.addEventListener('input', ()=>{
                inputOg.value = inputMirror.value;
            });

            /**@type {HTMLElement}*/
            const resumeBtn = dom.querySelector('#qr--modal-resume');
            resumeBtn.addEventListener('click', ()=>{
                this.debugController?.resume();
            });
            /**@type {HTMLElement}*/
            const stepBtn = dom.querySelector('#qr--modal-step');
            stepBtn.addEventListener('click', ()=>{
                this.debugController?.step();
            });
            /**@type {HTMLElement}*/
            const stepIntoBtn = dom.querySelector('#qr--modal-stepInto');
            stepIntoBtn.addEventListener('click', ()=>{
                this.debugController?.stepInto();
            });
            /**@type {HTMLElement}*/
            const stepOutBtn = dom.querySelector('#qr--modal-stepOut');
            stepOutBtn.addEventListener('click', ()=>{
                this.debugController?.stepOut();
            });
            /**@type {HTMLElement}*/
            const minimizeBtn = dom.querySelector('#qr--modal-minimize');
            minimizeBtn.addEventListener('click', ()=>{
                this.editorDom.classList.add('qr--minimized');
            });
            const maximizeBtn = dom.querySelector('#qr--modal-maximize');
            maximizeBtn.addEventListener('click', ()=>{
                this.editorDom.classList.remove('qr--minimized');
            });
            /**@type {boolean}*/
            let isResizing = false;
            let resizeStart;
            let wStart;
            /**@type {HTMLElement}*/
            const resizeHandle = dom.querySelector('#qr--resizeHandle');
            resizeHandle.addEventListener('pointerdown', (evt)=>{
                if (isResizing) return;
                isResizing = true;
                evt.preventDefault();
                resizeStart = evt.x;
                wStart = dom.querySelector('#qr--qrOptions').offsetWidth;
                const dragListener = debounce((evt)=>{
                    const w = wStart + resizeStart - evt.x;
                    dom.querySelector('#qr--qrOptions').style.setProperty('--width', `${w}px`);
                }, 5);
                window.addEventListener('pointerup', ()=>{
                    window.removeEventListener('pointermove', dragListener);
                    isResizing = false;
                }, { once:true });
                window.addEventListener('pointermove', dragListener);
            });

            await popupResult;

            window.removeEventListener('resize', resizeListener);
        } else {
            warn('failed to fetch qrEditor template');
        }
    }

    getEditorPosition(start, end, message = null) {
        const inputRect = this.editorMessage.getBoundingClientRect();
        const style = window.getComputedStyle(this.editorMessage);
        if (!this.clone) {
            this.clone = document.createElement('div');
            for (const key of style) {
                this.clone.style[key] = style[key];
            }
            this.clone.style.position = 'fixed';
            this.clone.style.visibility = 'hidden';
            const mo = new MutationObserver(muts=>{
                if (muts.find(it=>[...it.removedNodes].includes(this.editorMessage) || [...it.removedNodes].find(n=>n.contains(this.editorMessage)))) {
                    this.clone?.remove();
                    this.clone = null;
                }
            });
            mo.observe(document.body, { childList:true });
        }
        document.body.append(this.clone);
        this.clone.style.width = `${inputRect.width}px`;
        this.clone.style.height = `${inputRect.height}px`;
        this.clone.style.left = `${inputRect.left}px`;
        this.clone.style.top = `${inputRect.top}px`;
        this.clone.style.whiteSpace = style.whiteSpace;
        this.clone.style.tabSize = style.tabSize;
        const text = message ?? this.editorMessage.value;
        const before = text.slice(0, start);
        this.clone.textContent = before;
        const locator = document.createElement('span');
        locator.textContent = text.slice(start, end);
        this.clone.append(locator);
        this.clone.append(text.slice(end));
        this.clone.scrollTop = this.editorSyntax.scrollTop;
        this.clone.scrollLeft = this.editorSyntax.scrollLeft;
        const locatorRect = locator.getBoundingClientRect();
        const bodyRect = document.body.getBoundingClientRect();
        const location = {
            left: locatorRect.left - bodyRect.left,
            right: locatorRect.right - bodyRect.left,
            top: locatorRect.top - bodyRect.top,
            bottom: locatorRect.bottom - bodyRect.top,
        };
        // this.clone.remove();
        return location;
    }
    async executeFromEditor() {
        if (this.isExecuting) return;
        this.editorPopup.onClosing = ()=>false;
        const uuidCheck = /^[0-9a-z]{8}(-[0-9a-z]{4}){3}-[0-9a-z]{12}$/;
        const oText = this.message;
        this.isExecuting = true;
        this.editorDom.classList.add('qr--isExecuting');
        const noSyntax = this.editorDom.querySelector('#qr--modal-messageHolder').classList.contains('qr--noSyntax');
        if (noSyntax) {
            this.editorDom.querySelector('#qr--modal-messageHolder').classList.remove('qr--noSyntax');
        }
        this.editorExecuteBtn.classList.add('qr--busy');
        this.editorExecuteProgress.style.setProperty('--prog', '0');
        this.editorExecuteErrors.classList.remove('qr--hasErrors');
        this.editorExecuteResult.classList.remove('qr--hasResult');
        this.editorExecuteProgress.classList.remove('qr--error');
        this.editorExecuteProgress.classList.remove('qr--success');
        this.editorExecuteProgress.classList.remove('qr--paused');
        this.editorExecuteProgress.classList.remove('qr--aborted');
        this.editorExecuteErrors.innerHTML = '';
        this.editorExecuteResult.innerHTML = '';
        const syntax = this.editorDom.querySelector('#qr--modal-messageSyntaxInner');
        const updateScroll = (evt) => {
            let left = syntax.scrollLeft;
            let top = syntax.scrollTop;
            if (evt) {
                evt.preventDefault();
                left = syntax.scrollLeft + evt.deltaX;
                top = syntax.scrollTop + evt.deltaY;
                syntax.scrollTo({
                    behavior: 'instant',
                    left,
                    top,
                });
            }
            this.editorMessage.scrollTo({
                behavior: 'instant',
                left,
                top,
            });
        };
        const updateScrollDebounced = updateScroll;
        syntax.addEventListener('wheel', (evt)=>{
            updateScrollDebounced(evt);
        });
        syntax.addEventListener('scroll', (evt)=>{
            updateScrollDebounced();
        });
        try {
            this.abortController = new SlashCommandAbortController();
            this.debugController = new SlashCommandDebugController();
            this.debugController.onBreakPoint = async(closure, executor)=>{
                this.editorDom.classList.add('qr--isPaused');
                syntax.innerHTML = hljs.highlight(`${closure.fullText}${closure.fullText.slice(-1) == '\n' ? ' ' : ''}`, { language:'stscript', ignoreIllegals:true })?.value;
                this.editorMessageLabel.innerHTML = '';
                if (uuidCheck.test(closure.source)) {
                    const p0 = document.createElement('span'); {
                        p0.textContent = 'anonymous: ';
                        this.editorMessageLabel.append(p0);
                    }
                    const p1 = document.createElement('strong'); {
                        p1.textContent = executor.source.slice(0,5);
                        this.editorMessageLabel.append(p1);
                    }
                    const p2 = document.createElement('span'); {
                        p2.textContent = executor.source.slice(5, -5);
                        this.editorMessageLabel.append(p2);
                    }
                    const p3 = document.createElement('strong'); {
                        p3.textContent = executor.source.slice(-5);
                        this.editorMessageLabel.append(p3);
                    }
                } else {
                    this.editorMessageLabel.textContent = executor.source;
                }
                const source = closure.source;
                this.editorDebugState.innerHTML = '';
                let ci = -1;
                const varNames = [];
                const macroNames = [];
                /**
                 * @param {SlashCommandScope} scope
                 */
                const buildVars = (scope, isCurrent = false)=>{
                    if (!isCurrent) {
                        ci--;
                    }
                    const c = this.debugController.stack.slice(ci)[0];
                    const wrap = document.createElement('div'); {
                        wrap.classList.add('qr--scope');
                        if (isCurrent) {
                            const executor = this.debugController.cmdStack.slice(-1)[0];
                            { // named args
                                const namedTitle = document.createElement('div'); {
                                    namedTitle.classList.add('qr--title');
                                    namedTitle.textContent = `Named Args - /${executor.name}`;
                                    if (executor.command.name == 'run') {
                                        namedTitle.textContent += `${(executor.name == ':' ? '' : ' ')}${executor.unnamedArgumentList[0]?.value}`;
                                    }
                                    wrap.append(namedTitle);
                                }
                                const keys = new Set([...Object.keys(this.debugController.namedArguments ?? {}), ...(executor.namedArgumentList ?? []).map(it=>it.name)]);
                                for (const key of keys) {
                                    if (key[0] == '_') continue;
                                    const item = document.createElement('div'); {
                                        item.classList.add('qr--var');
                                        const k = document.createElement('div'); {
                                            k.classList.add('qr--key');
                                            k.textContent = key;
                                            item.append(k);
                                        }
                                        const vUnresolved = document.createElement('div'); {
                                            vUnresolved.classList.add('qr--val');
                                            vUnresolved.classList.add('qr--singleCol');
                                            const val = executor.namedArgumentList.find(it=>it.name == key)?.value;
                                            if (val instanceof SlashCommandClosure) {
                                                vUnresolved.classList.add('qr--closure');
                                                vUnresolved.title = val.rawText;
                                                vUnresolved.textContent = val.toString();
                                            } else if (val === undefined) {
                                                vUnresolved.classList.add('qr--undefined');
                                                vUnresolved.textContent = 'undefined';
                                            } else {
                                                let jsonVal;
                                                try { jsonVal = JSON.parse(val); } catch { /* empty */ }
                                                if (jsonVal && typeof jsonVal == 'object') {
                                                    vUnresolved.textContent = JSON.stringify(jsonVal, null, 2);
                                                } else {
                                                    vUnresolved.textContent = val;
                                                    vUnresolved.classList.add('qr--simple');
                                                }
                                            }
                                            item.append(vUnresolved);
                                        }
                                        const vResolved = document.createElement('div'); {
                                            vResolved.classList.add('qr--val');
                                            vResolved.classList.add('qr--singleCol');
                                            if (this.debugController.namedArguments === undefined) {
                                                vResolved.classList.add('qr--unresolved');
                                            } else {
                                                const val = this.debugController.namedArguments?.[key];
                                                if (val instanceof SlashCommandClosure) {
                                                    vResolved.classList.add('qr--closure');
                                                    vResolved.title = val.rawText;
                                                    vResolved.textContent = val.toString();
                                                } else if (val === undefined) {
                                                    vResolved.classList.add('qr--undefined');
                                                    vResolved.textContent = 'undefined';
                                                } else {
                                                    let jsonVal;
                                                    try { jsonVal = JSON.parse(val); } catch { /* empty */ }
                                                    if (jsonVal && typeof jsonVal == 'object') {
                                                        vResolved.textContent = JSON.stringify(jsonVal, null, 2);
                                                    } else {
                                                        vResolved.textContent = val;
                                                        vResolved.classList.add('qr--simple');
                                                    }
                                                }
                                            }
                                            item.append(vResolved);
                                        }
                                        wrap.append(item);
                                    }
                                }
                            }
                            { // unnamed args
                                const unnamedTitle = document.createElement('div'); {
                                    unnamedTitle.classList.add('qr--title');
                                    unnamedTitle.textContent = `Unnamed Args - /${executor.name}`;
                                    if (executor.command.name == 'run') {
                                        unnamedTitle.textContent += `${(executor.name == ':' ? '' : ' ')}${executor.unnamedArgumentList[0]?.value}`;
                                    }
                                    wrap.append(unnamedTitle);
                                }
                                let i = 0;
                                let unnamed = this.debugController.unnamedArguments ?? [];
                                if (!Array.isArray(unnamed)) unnamed = [unnamed];
                                while (unnamed.length < executor.unnamedArgumentList?.length ?? 0) unnamed.push(undefined);
                                unnamed = unnamed.map((it,idx)=>[executor.unnamedArgumentList?.[idx], it]);
                                for (const arg of unnamed) {
                                    i++;
                                    const item = document.createElement('div'); {
                                        item.classList.add('qr--var');
                                        const k = document.createElement('div'); {
                                            k.classList.add('qr--key');
                                            k.textContent = i.toString();
                                            item.append(k);
                                        }
                                        const vUnresolved = document.createElement('div'); {
                                            vUnresolved.classList.add('qr--val');
                                            vUnresolved.classList.add('qr--singleCol');
                                            const val = arg[0]?.value;
                                            if (val instanceof SlashCommandClosure) {
                                                vUnresolved.classList.add('qr--closure');
                                                vUnresolved.title = val.rawText;
                                                vUnresolved.textContent = val.toString();
                                            } else if (val === undefined) {
                                                vUnresolved.classList.add('qr--undefined');
                                                vUnresolved.textContent = 'undefined';
                                            } else {
                                                let jsonVal;
                                                try { jsonVal = JSON.parse(val); } catch { /* empty */ }
                                                if (jsonVal && typeof jsonVal == 'object') {
                                                    vUnresolved.textContent = JSON.stringify(jsonVal, null, 2);
                                                } else {
                                                    vUnresolved.textContent = val;
                                                    vUnresolved.classList.add('qr--simple');
                                                }
                                            }
                                            item.append(vUnresolved);
                                        }
                                        const vResolved = document.createElement('div'); {
                                            vResolved.classList.add('qr--val');
                                            vResolved.classList.add('qr--singleCol');
                                            if (this.debugController.unnamedArguments === undefined) {
                                                vResolved.classList.add('qr--unresolved');
                                            } else if ((Array.isArray(this.debugController.unnamedArguments) ? this.debugController.unnamedArguments : [this.debugController.unnamedArguments]).length < i) {
                                                // do nothing
                                            } else {
                                                const val = arg[1];
                                                if (val instanceof SlashCommandClosure) {
                                                    vResolved.classList.add('qr--closure');
                                                    vResolved.title = val.rawText;
                                                    vResolved.textContent = val.toString();
                                                } else if (val === undefined) {
                                                    vResolved.classList.add('qr--undefined');
                                                    vResolved.textContent = 'undefined';
                                                } else {
                                                    let jsonVal;
                                                    try { jsonVal = JSON.parse(val); } catch { /* empty */ }
                                                    if (jsonVal && typeof jsonVal == 'object') {
                                                        vResolved.textContent = JSON.stringify(jsonVal, null, 2);
                                                    } else {
                                                        vResolved.textContent = val;
                                                        vResolved.classList.add('qr--simple');
                                                    }
                                                }
                                            }
                                            item.append(vResolved);
                                        }
                                        wrap.append(item);
                                    }
                                }
                            }
                        }
                        // current scope
                        const title = document.createElement('div'); {
                            title.classList.add('qr--title');
                            title.textContent = isCurrent ? 'Current Scope' : 'Parent Scope';
                            if (c.source == source) {
                                let hi;
                                title.addEventListener('pointerenter', ()=>{
                                    const loc = this.getEditorPosition(Math.max(0, c.executorList[0].start - 1), c.executorList.slice(-1)[0].end, c.fullText);
                                    const layer = syntax.getBoundingClientRect();
                                    hi = document.createElement('div');
                                    hi.classList.add('qr--highlight-secondary');
                                    hi.style.left = `${loc.left - layer.left}px`;
                                    hi.style.width = `${loc.right - loc.left}px`;
                                    hi.style.top = `${loc.top - layer.top + syntax.scrollTop}px`;
                                    hi.style.height = `${loc.bottom - loc.top}px`;
                                    syntax.append(hi);
                                });
                                title.addEventListener('pointerleave', ()=>hi?.remove());
                            }
                            wrap.append(title);
                        }
                        for (const key of Object.keys(scope.variables)) {
                            const isHidden = varNames.includes(key);
                            if (!isHidden) varNames.push(key);
                            const item = document.createElement('div'); {
                                item.classList.add('qr--var');
                                if (isHidden) item.classList.add('qr--isHidden');
                                const k = document.createElement('div'); {
                                    k.classList.add('qr--key');
                                    k.textContent = key;
                                    item.append(k);
                                }
                                const v = document.createElement('div'); {
                                    v.classList.add('qr--val');
                                    const val = scope.variables[key];
                                    if (val instanceof SlashCommandClosure) {
                                        v.classList.add('qr--closure');
                                        v.title = val.rawText;
                                        v.textContent = val.toString();
                                    } else if (val === undefined) {
                                        v.classList.add('qr--undefined');
                                        v.textContent = 'undefined';
                                    } else {
                                        let jsonVal;
                                        try { jsonVal = JSON.parse(val); } catch { /* empty */ }
                                        if (jsonVal && typeof jsonVal == 'object') {
                                            v.textContent = JSON.stringify(jsonVal, null, 2);
                                        } else {
                                            v.textContent = val;
                                            v.classList.add('qr--simple');
                                        }
                                    }
                                    item.append(v);
                                }
                                wrap.append(item);
                            }
                        }
                        for (const key of Object.keys(scope.macros)) {
                            const isHidden = macroNames.includes(key);
                            if (!isHidden) macroNames.push(key);
                            const item = document.createElement('div'); {
                                item.classList.add('qr--macro');
                                if (isHidden) item.classList.add('qr--isHidden');
                                const k = document.createElement('div'); {
                                    k.classList.add('qr--key');
                                    k.textContent = key;
                                    item.append(k);
                                }
                                const v = document.createElement('div'); {
                                    v.classList.add('qr--val');
                                    const val = scope.macros[key];
                                    if (val instanceof SlashCommandClosure) {
                                        v.classList.add('qr--closure');
                                        v.title = val.rawText;
                                        v.textContent = val.toString();
                                    } else if (val === undefined) {
                                        v.classList.add('qr--undefined');
                                        v.textContent = 'undefined';
                                    } else {
                                        let jsonVal;
                                        try { jsonVal = JSON.parse(val); } catch { /* empty */ }
                                        if (jsonVal && typeof jsonVal == 'object') {
                                            v.textContent = JSON.stringify(jsonVal, null, 2);
                                        } else {
                                            v.textContent = val;
                                            v.classList.add('qr--simple');
                                        }
                                    }
                                    item.append(v);
                                }
                                wrap.append(item);
                            }
                        }
                        const pipeItem = document.createElement('div'); {
                            pipeItem.classList.add('qr--pipe');
                            const k = document.createElement('div'); {
                                k.classList.add('qr--key');
                                k.textContent = 'pipe';
                                pipeItem.append(k);
                            }
                            const v = document.createElement('div'); {
                                v.classList.add('qr--val');
                                const val = scope.pipe;
                                if (val instanceof SlashCommandClosure) {
                                    v.classList.add('qr--closure');
                                    v.title = val.rawText;
                                    v.textContent = val.toString();
                                } else if (val === undefined) {
                                    v.classList.add('qr--undefined');
                                    v.textContent = 'undefined';
                                } else {
                                    let jsonVal;
                                    try { jsonVal = JSON.parse(val); } catch { /* empty */ }
                                    if (jsonVal && typeof jsonVal == 'object') {
                                        v.textContent = JSON.stringify(jsonVal, null, 2);
                                    } else {
                                        v.textContent = val;
                                        v.classList.add('qr--simple');
                                    }
                                }
                                pipeItem.append(v);
                            }
                            wrap.append(pipeItem);
                        }
                        if (scope.parent) {
                            wrap.append(buildVars(scope.parent));
                        }
                    }
                    return wrap;
                };
                const buildStack = ()=>{
                    const wrap = document.createElement('div'); {
                        wrap.classList.add('qr--stack');
                        const title = document.createElement('div'); {
                            title.classList.add('qr--title');
                            title.textContent = 'Call Stack';
                            wrap.append(title);
                        }
                        let ei = -1;
                        for (const executor of this.debugController.cmdStack.toReversed()) {
                            ei++;
                            const c = this.debugController.stack.toReversed()[ei];
                            const item = document.createElement('div'); {
                                item.classList.add('qr--item');
                                if (executor.source == source) {
                                    let hi;
                                    item.addEventListener('pointerenter', ()=>{
                                        const loc = this.getEditorPosition(Math.max(0, executor.start - 1), executor.end, c.fullText);
                                        const layer = syntax.getBoundingClientRect();
                                        hi = document.createElement('div');
                                        hi.classList.add('qr--highlight-secondary');
                                        hi.style.left = `${loc.left - layer.left}px`;
                                        hi.style.width = `${loc.right - loc.left}px`;
                                        hi.style.top = `${loc.top - layer.top + syntax.scrollTop}px`;
                                        hi.style.height = `${loc.bottom - loc.top}px`;
                                        syntax.append(hi);
                                    });
                                    item.addEventListener('pointerleave', ()=>hi?.remove());
                                }
                                const cmd = document.createElement('div'); {
                                    cmd.classList.add('qr--cmd');
                                    cmd.textContent = `/${executor.name}`;
                                    if (executor.command.name == 'run') {
                                        cmd.textContent += `${(executor.name == ':' ? '' : ' ')}${executor.unnamedArgumentList[0]?.value}`;
                                    }
                                    item.append(cmd);
                                }
                                const src = document.createElement('div'); {
                                    src.classList.add('qr--source');
                                    const line = closure.fullText.slice(0, executor.start).split('\n').length;
                                    if (uuidCheck.test(executor.source)) {
                                        const p1 = document.createElement('span'); {
                                            p1.classList.add('qr--fixed');
                                            p1.textContent = executor.source.slice(0,5);
                                            src.append(p1);
                                        }
                                        const p2 = document.createElement('span'); {
                                            p2.classList.add('qr--truncated');
                                            p2.textContent = '…';
                                            src.append(p2);
                                        }
                                        const p3 = document.createElement('span'); {
                                            p3.classList.add('qr--fixed');
                                            p3.textContent = `${executor.source.slice(-5)}:${line}`;
                                            src.append(p3);
                                        }
                                        src.title = `anonymous: ${executor.source}`;
                                    } else {
                                        src.textContent = `${executor.source}:${line}`;
                                    }
                                    item.append(src);
                                }
                                wrap.append(item);
                            }
                        }
                    }
                    return wrap;
                };
                this.editorDebugState.append(buildVars(closure.scope, true));
                this.editorDebugState.append(buildStack());
                this.editorDebugState.classList.add('qr--active');
                const loc = this.getEditorPosition(Math.max(0, executor.start - 1), executor.end, closure.fullText);
                const layer = syntax.getBoundingClientRect();
                const hi = document.createElement('div');
                hi.classList.add('qr--highlight');
                if (this.debugController.namedArguments === undefined) {
                    hi.classList.add('qr--unresolved');
                }
                hi.style.left = `${loc.left - layer.left}px`;
                hi.style.width = `${loc.right - loc.left}px`;
                hi.style.top = `${loc.top - layer.top + syntax.scrollTop}px`;
                hi.style.height = `${loc.bottom - loc.top}px`;
                syntax.append(hi);
                const isStepping = await this.debugController.awaitContinue();
                hi.remove();
                this.editorDebugState.textContent = '';
                this.editorDebugState.classList.remove('qr--active');
                this.editorDom.classList.remove('qr--isPaused');
                return isStepping;
            };
            const result = await this.onDebug(this);
            if (this.abortController?.signal?.aborted) {
                this.editorExecuteProgress.classList.add('qr--aborted');
            } else {
                this.editorExecuteResult.textContent = result?.toString();
                this.editorExecuteResult.classList.add('qr--hasResult');
                this.editorExecuteProgress.classList.add('qr--success');
            }
            this.editorExecuteProgress.classList.remove('qr--paused');
        } catch (ex) {
            this.editorExecuteErrors.classList.add('qr--hasErrors');
            this.editorExecuteProgress.classList.add('qr--error');
            this.editorExecuteProgress.classList.remove('qr--paused');
            if (ex instanceof SlashCommandParserError) {
                this.editorExecuteErrors.innerHTML = `
                    <div>${ex.message}</div>
                    <div>Line: ${ex.line} Column: ${ex.column}</div>
                    <pre style="text-align:left;">${ex.hint}</pre>
                `;
            } else {
                this.editorExecuteErrors.innerHTML = `
                    <div>${ex.message}</div>
                `;
            }
        }
        if (noSyntax) {
            this.editorDom.querySelector('#qr--modal-messageHolder').classList.add('qr--noSyntax');
        }
        this.editorMessageLabel.innerHTML = '';
        this.editorMessageLabel.textContent = 'Message / Command: ';
        this.editorMessage.value = oText;
        this.editorMessage.dispatchEvent(new Event('input', { bubbles:true }));
        this.editorExecutePromise = null;
        this.editorExecuteBtn.classList.remove('qr--busy');
        this.editorDom.classList.remove('qr--isExecuting');
        this.isExecuting = false;
        this.editorPopup.onClosing = null;
    }

    updateEditorProgress(done, total) {
        this.editorExecuteProgress.style.setProperty('--prog', `${done / total * 100}`);
    }




    delete() {
        if (this.onDelete) {
            this.unrender();
            this.unrenderSettings();
            this.onDelete(this);
        }
    }

    /**
     * @param {string} value
     */
    updateMessage(value) {
        if (this.onUpdate) {
            if (this.settingsDomMessage && this.settingsDomMessage.value != value) {
                this.settingsDomMessage.value = value;
            }
            this.message = value;
            this.updateRender();
            this.onUpdate(this);
        }
    }

    /**
     * @param {string} value
     */
    updateIcon(value) {
        if (this.onUpdate) {
            if (value === null) return;
            if (this.settingsDomIcon) {
                if (this.icon != value) {
                    if (value == '') {
                        if (this.icon) {
                            this.settingsDomIcon.classList.remove(this.icon);
                        }
                        this.settingsDomIcon.textContent = '…';
                        this.settingsDomIcon.classList.remove('fa-solid');
                    } else {
                        if (this.icon) {
                            this.settingsDomIcon.classList.remove(this.icon);
                        } else {
                            this.settingsDomIcon.classList.add('fa-solid');
                        }
                        this.settingsDomIcon.classList.add(value);
                    }
                }
            }
            this.icon = value;
            this.updateRender();
            this.onUpdate(this);
        }
    }

    /**
     * @param {boolean} value
     */
    updateShowLabel(value) {
        if (this.onUpdate) {
            this.showLabel = value;
            this.updateRender();
            this.onUpdate(this);
        }
    }

    /**
     * @param {string} value
     */
    updateLabel(value) {
        if (this.onUpdate) {
            if (this.settingsDomLabel && this.settingsDomLabel.value != value) {
                this.settingsDomLabel.value = value;
            }
            this.label = value;
            this.updateRender();
            this.onUpdate(this);
        }
    }

    /**
     * @param {string} value
     */
    updateTitle(value) {
        if (this.onUpdate) {
            this.title = value;
            this.updateRender();
            this.onUpdate(this);
        }
    }

    updateContext() {
        if (this.onUpdate) {
            this.updateRender();
            this.onUpdate(this);
        }
    }
    addContextLink(cl) {
        this.contextList.push(cl);
        this.updateContext();
    }
    removeContextLink(setName) {
        const idx = this.contextList.findIndex(it=>it.set.name == setName);
        if (idx > -1) {
            this.contextList.splice(idx, 1);
            this.updateContext();
        }
    }
    clearContextLinks() {
        if (this.contextList.length) {
            this.contextList.splice(0, this.contextList.length);
            this.updateContext();
        }
    }


    async execute(args = {}, isEditor = false, isRun = false, options = {}) {
        if (this.message?.length > 0 && this.onExecute) {
            const scope = new SlashCommandScope();
            for (const key of Object.keys(args)) {
                if (key[0] == '_') continue;
                if (key == 'isAutoExecute') continue;
                scope.setMacro(`arg::${key}`, args[key]);
            }
            scope.setMacro('arg::*', '');
            if (isEditor) {
                this.abortController = new SlashCommandAbortController();
            }
            return await this.onExecute(this, {
                message: this.message,
                isAutoExecute: args.isAutoExecute ?? false,
                isEditor,
                isRun,
                scope,
                executionOptions: options,
            });
        }
    }




    toJSON() {
        return {
            id: this.id,
            icon: this.icon,
            showLabel: this.showLabel,
            label: this.label,
            title: this.title,
            message: this.message,
            contextList: this.contextList,
            preventAutoExecute: this.preventAutoExecute,
            isHidden: this.isHidden,
            executeOnStartup: this.executeOnStartup,
            executeOnUser: this.executeOnUser,
            executeOnAi: this.executeOnAi,
            executeOnChatChange: this.executeOnChatChange,
            executeOnGroupMemberDraft: this.executeOnGroupMemberDraft,
            executeOnNewChat: this.executeOnNewChat,
            automationId: this.automationId,
        };
    }
}



---
File: /src/QuickReplyConfig.js
---

import { getSortableDelay } from '../../../utils.js';
import { QuickReplySetLink } from './QuickReplySetLink.js';
import { QuickReplySet } from './QuickReplySet.js';

export class QuickReplyConfig {
    /**@type {QuickReplySetLink[]}*/ setList = [];
    /**@type {Boolean}*/ isGlobal;

    /**@type {Function}*/ onUpdate;
    /**@type {Function}*/ onRequestEditSet;

    /**@type {HTMLElement}*/ dom;
    /**@type {HTMLElement}*/ setListDom;




    static from(props) {
        props.setList = props.setList?.map(it=>QuickReplySetLink.from(it))?.filter(it=>it.set) ?? [];
        const instance = Object.assign(new this(), props);
        instance.init();
        return instance;
    }




    init() {
        this.setList.forEach(it=>this.hookQuickReplyLink(it));
    }


    hasSet(qrs) {
        return this.setList.find(it=>it.set == qrs) != null;
    }
    addSet(qrs, isVisible = true) {
        if (!this.hasSet(qrs)) {
            const qrl = new QuickReplySetLink();
            qrl.set = qrs;
            qrl.isVisible = isVisible;
            this.hookQuickReplyLink(qrl);
            this.setList.push(qrl);
            this.setListDom.append(qrl.renderSettings(this.setList.length - 1));
            this.update();
        }
    }
    removeSet(qrs) {
        const idx = this.setList.findIndex(it=>it.set == qrs);
        if (idx > -1) {
            this.setList.splice(idx, 1);
            this.update();
            this.updateSetListDom();
        }
    }




    renderSettingsInto(/**@type {HTMLElement}*/root) {
        /**@type {HTMLElement}*/
        this.setListDom = root.querySelector('.qr--setList');
        root.querySelector('.qr--setListAdd').addEventListener('click', ()=>{
            const newSet = QuickReplySet.list.find(qr=>!this.setList.find(qrl=>qrl.set == qr));
            if (newSet) {
                this.addSet(newSet);
            } else {
                toastr.warning('All existing QR Sets have already been added.');
            }
        });
        this.updateSetListDom();
    }
    updateSetListDom() {
        this.setListDom.innerHTML = '';
        // @ts-ignore
        $(this.setListDom).sortable({
            delay: getSortableDelay(),
            stop: ()=>this.onSetListSort(),
        });
        this.setList.filter(it=>!it.set.isDeleted).forEach((qrl,idx)=>this.setListDom.append(qrl.renderSettings(idx)));
    }


    onSetListSort() {
        this.setList = Array.from(this.setListDom.children).map((it,idx)=>{
            const qrl = this.setList[Number(it.getAttribute('data-order'))];
            qrl.index = idx;
            it.setAttribute('data-order', String(idx));
            return qrl;
        });
        this.update();
    }




    /**
     * @param {QuickReplySetLink} qrl
     */
    hookQuickReplyLink(qrl) {
        qrl.onDelete = ()=>this.deleteQuickReplyLink(qrl);
        qrl.onUpdate = ()=>this.update();
        qrl.onRequestEditSet = ()=>this.requestEditSet(qrl.set);
    }

    deleteQuickReplyLink(qrl) {
        this.setList.splice(this.setList.indexOf(qrl), 1);
        this.update();
    }

    update() {
        if (this.onUpdate) {
            this.onUpdate(this);
        }
    }

    requestEditSet(qrs) {
        if (this.onRequestEditSet) {
            this.onRequestEditSet(qrs);
        }
    }

    toJSON() {
        return {
            setList: this.setList,
        };
    }
}



---
File: /src/QuickReplyContextLink.js
---

import { QuickReplySet } from './QuickReplySet.js';

export class QuickReplyContextLink {
    static from(props) {
        props.set = QuickReplySet.get(props.set);
        const x = Object.assign(new this(), props);
        return x;
    }




    /**@type {QuickReplySet}*/ set;
    /**@type {Boolean}*/ isChained = false;

    toJSON() {
        return {
            set: this.set?.name,
            isChained: this.isChained,
        };
    }
}



---
File: /src/QuickReplySet.js
---

import { getRequestHeaders, substituteParams } from '../../../../script.js';
import { Popup, POPUP_RESULT, POPUP_TYPE } from '../../../popup.js';
import { executeSlashCommands, executeSlashCommandsOnChatInput, executeSlashCommandsWithOptions } from '../../../slash-commands.js';
import { SlashCommandParser } from '../../../slash-commands/SlashCommandParser.js';
import { SlashCommandScope } from '../../../slash-commands/SlashCommandScope.js';
import { debounceAsync, log, warn } from '../index.js';
import { QuickReply } from './QuickReply.js';

export class QuickReplySet {
    /**@type {QuickReplySet[]}*/ static list = [];


    static from(props) {
        props.qrList = []; //props.qrList?.map(it=>QuickReply.from(it));
        const instance = Object.assign(new this(), props);
        // instance.init();
        return instance;
    }

    /**
     * @param {string} name - name of the QuickReplySet
     */
    static get(name) {
        return this.list.find(it=>it.name == name);
    }




    /**@type {string}*/ name;
    /**@type {boolean}*/ disableSend = false;
    /**@type {boolean}*/ placeBeforeInput = false;
    /**@type {boolean}*/ injectInput = false;
    /**@type {string}*/ color = 'transparent';
    /**@type {boolean}*/ onlyBorderColor = false;
    /**@type {QuickReply[]}*/ qrList = [];

    /**@type {number}*/ idIndex = 0;

    /**@type {boolean}*/ isDeleted = false;

    /**@type {function}*/ save;

    /**@type {HTMLElement}*/ dom;
    /**@type {HTMLElement}*/ settingsDom;




    constructor() {
        this.save = debounceAsync(()=>this.performSave(), 200);
    }

    init() {
        this.qrList.forEach(qr=>this.hookQuickReply(qr));
    }




    unrender() {
        this.dom?.remove();
        this.dom = null;
    }
    render() {
        this.unrender();
        if (!this.dom) {
            const root = document.createElement('div'); {
                this.dom = root;
                root.classList.add('qr--buttons');
                this.updateColor();
                this.qrList.filter(qr=>!qr.isHidden).forEach(qr=>{
                    root.append(qr.render());
                });
            }
        }
        return this.dom;
    }
    rerender() {
        if (!this.dom) return;
        this.dom.innerHTML = '';
        this.qrList.filter(qr=>!qr.isHidden).forEach(qr=>{
            this.dom.append(qr.render());
        });
    }
    updateColor() {
        if (!this.dom) return;
        if (this.color && this.color != 'transparent') {
            this.dom.style.setProperty('--qr--color', this.color);
            this.dom.classList.add('qr--color');
            if (this.onlyBorderColor) {
                this.dom.classList.add('qr--borderColor');
            } else {
                this.dom.classList.remove('qr--borderColor');
            }
        } else {
            this.dom.style.setProperty('--qr--color', 'transparent');
            this.dom.classList.remove('qr--color');
            this.dom.classList.remove('qr--borderColor');
        }
    }




    renderSettings() {
        if (!this.settingsDom) {
            this.settingsDom = document.createElement('div'); {
                this.settingsDom.classList.add('qr--set-qrListContents');
                this.qrList.forEach((qr,idx)=>{
                    this.renderSettingsItem(qr, idx);
                });
            }
        }
        return this.settingsDom;
    }
    /**
     *
     * @param {QuickReply} qr
     * @param {number} idx
     */
    renderSettingsItem(qr, idx) {
        this.settingsDom.append(qr.renderSettings(idx));
    }




    /**
     *
     * @param {QuickReply} qr
     */
    async debug(qr) {
        const parser = new SlashCommandParser();
        const closure = parser.parse(qr.message, true, [], qr.abortController, qr.debugController);
        closure.source = `${this.name}.${qr.label}`;
        closure.onProgress = (done, total) => qr.updateEditorProgress(done, total);
        closure.scope.setMacro('arg::*', '');
        return (await closure.execute())?.pipe;
    }
    /**
     *
     * @param {QuickReply} qr The QR to execute.
     * @param {object} options
     * @param {string} [options.message] (null) altered message to be used
     * @param {boolean} [options.isAutoExecute] (false) whether the execution is triggered by auto execute
     * @param {boolean} [options.isEditor] (false) whether the execution is triggered by the QR editor
     * @param {boolean} [options.isRun] (false) whether the execution is triggered by /run or /: (window.executeQuickReplyByName)
     * @param {SlashCommandScope} [options.scope] (null) scope to be used when running the command
     * @param {import('../../../slash-commands.js').ExecuteSlashCommandsOptions} [options.executionOptions] ({}) further execution options
     * @returns
     */
    async executeWithOptions(qr, options = {}) {
        options = Object.assign({
            message:null,
            isAutoExecute:false,
            isEditor:false,
            isRun:false,
            scope:null,
            executionOptions:{},
        }, options);
        const execOptions = options.executionOptions;
        /**@type {HTMLTextAreaElement}*/
        const ta = document.querySelector('#send_textarea');
        const finalMessage = options.message ?? qr.message;
        let input = ta.value;
        if (!options.isAutoExecute && !options.isEditor && !options.isRun && this.injectInput && input.length > 0) {
            if (this.placeBeforeInput) {
                input = `${finalMessage} ${input}`;
            } else {
                input = `${input} ${finalMessage}`;
            }
        } else {
            input = `${finalMessage} `;
        }

        if (input[0] == '/' && !this.disableSend) {
            let result;
            if (options.isAutoExecute || options.isRun) {
                result = await executeSlashCommandsWithOptions(input, Object.assign(execOptions, {
                    handleParserErrors: true,
                    scope: options.scope,
                    source: `${this.name}.${qr.label}`,
                }));
            } else if (options.isEditor) {
                result = await executeSlashCommandsWithOptions(input, Object.assign(execOptions, {
                    handleParserErrors: false,
                    scope: options.scope,
                    abortController: qr.abortController,
                    source: `${this.name}.${qr.label}`,
                    onProgress: (done, total) => qr.updateEditorProgress(done, total),
                }));
            } else {
                result = await executeSlashCommandsOnChatInput(input, Object.assign(execOptions, {
                    scope: options.scope,
                    source: `${this.name}.${qr.label}`,
                }));
            }
            return typeof result === 'object' ? result?.pipe : '';
        }

        ta.value = substituteParams(input);
        ta.focus();

        if (!this.disableSend) {
            // @ts-ignore
            document.querySelector('#send_but').click();
        }
    }
    /**
     * @param {QuickReply} qr
     * @param {string} [message] - optional altered message to be used
     * @param {SlashCommandScope} [scope] - optional scope to be used when running the command
     */
    async execute(qr, message = null, isAutoExecute = false, scope = null) {
        return this.executeWithOptions(qr, {
            message,
            isAutoExecute,
            scope,
        });
    }




    addQuickReply(data = {}) {
        const id = Math.max(this.idIndex, this.qrList.reduce((max,qr)=>Math.max(max,qr.id),0)) + 1;
        data.id =
        this.idIndex = id + 1;
        const qr = QuickReply.from(data);
        this.qrList.push(qr);
        this.hookQuickReply(qr);
        if (this.settingsDom) {
            this.renderSettingsItem(qr, this.qrList.length - 1);
        }
        if (this.dom) {
            this.dom.append(qr.render());
        }
        this.save();
        return qr;
    }
    addQuickReplyFromText(qrJson) {
        let data;
        if (qrJson) {
            try {
                data = JSON.parse(qrJson ?? '{}');
                delete data.id;
            } catch {
                // not JSON data
            }
            if (data) {
                // JSON data
                if (data.label === undefined || data.message === undefined) {
                    // not a QR
                    toastr.error('Not a QR.');
                    return;
                }
            } else {
                // no JSON, use plaintext as QR message
                data = { message: qrJson };
            }
        } else {
            data = {};
        }
        const newQr = this.addQuickReply(data);
        return newQr;
    }

    /**
     *
     * @param {QuickReply} qr
     */
    hookQuickReply(qr) {
        qr.onDebug = ()=>this.debug(qr);
        qr.onExecute = (_, options)=>this.executeWithOptions(qr, options);
        qr.onDelete = ()=>this.removeQuickReply(qr);
        qr.onUpdate = ()=>this.save();
        qr.onInsertBefore = (qrJson)=>{
            this.addQuickReplyFromText(qrJson);
            const newQr = this.qrList.pop();
            this.qrList.splice(this.qrList.indexOf(qr), 0, newQr);
            if (qr.settingsDom) {
                qr.settingsDom.insertAdjacentElement('beforebegin', newQr.settingsDom);
            }
            this.save();
        };
        qr.onTransfer = async()=>{
            /**@type {HTMLSelectElement} */
            let sel;
            let isCopy = false;
            const dom = document.createElement('div'); {
                dom.classList.add('qr--transferModal');
                const title = document.createElement('h3'); {
                    title.textContent = 'Transfer Quick Reply';
                    dom.append(title);
                }
                const subTitle = document.createElement('h4'); {
                    const entryName = qr.label;
                    const bookName = this.name;
                    subTitle.textContent = `${bookName}: ${entryName}`;
                    dom.append(subTitle);
                }
                sel = document.createElement('select'); {
                    sel.classList.add('qr--transferSelect');
                    sel.setAttribute('autofocus', '1');
                    const noOpt = document.createElement('option'); {
                        noOpt.value = '';
                        noOpt.textContent = '-- Select QR Set --';
                        sel.append(noOpt);
                    }
                    for (const qrs of QuickReplySet.list) {
                        const opt = document.createElement('option'); {
                            opt.value = qrs.name;
                            opt.textContent = qrs.name;
                            sel.append(opt);
                        }
                    }
                    sel.addEventListener('keyup', (evt)=>{
                        if (evt.key == 'Shift') {
                            (dlg.dom ?? dlg.dlg).classList.remove('qr--isCopy');
                            return;
                        }
                    });
                    sel.addEventListener('keydown', (evt)=>{
                        if (evt.key == 'Shift') {
                            (dlg.dom ?? dlg.dlg).classList.add('qr--isCopy');
                            return;
                        }
                        if (!evt.ctrlKey && !evt.altKey && evt.key == 'Enter') {
                            evt.preventDefault();
                            if (evt.shiftKey) isCopy = true;
                            dlg.completeAffirmative();
                        }
                    });
                    dom.append(sel);
                }
                const hintP = document.createElement('p'); {
                    const hint = document.createElement('small'); {
                        hint.textContent = 'Type or arrows to select QR Set. Enter to transfer. Shift+Enter to copy.';
                        hintP.append(hint);
                    }
                    dom.append(hintP);
                }
            }
            const dlg = new Popup(dom, POPUP_TYPE.CONFIRM, null, { okButton:'Transfer', cancelButton:'Cancel' });
            const copyBtn = document.createElement('div'); {
                copyBtn.classList.add('qr--copy');
                copyBtn.classList.add('menu_button');
                copyBtn.textContent = 'Copy';
                copyBtn.addEventListener('click', ()=>{
                    isCopy = true;
                    dlg.completeAffirmative();
                });
                (dlg.ok ?? dlg.okButton).insertAdjacentElement('afterend', copyBtn);
            }
            const prom = dlg.show();
            sel.focus();
            await prom;
            if (dlg.result == POPUP_RESULT.AFFIRMATIVE) {
                const qrs = QuickReplySet.list.find(it=>it.name == sel.value);
                qrs.addQuickReply(qr.toJSON());
                if (!isCopy) {
                    qr.delete();
                }
            }
        };
    }

    removeQuickReply(qr) {
        this.qrList.splice(this.qrList.indexOf(qr), 1);
        this.save();
    }


    toJSON() {
        return {
            version: 2,
            name: this.name,
            disableSend: this.disableSend,
            placeBeforeInput: this.placeBeforeInput,
            injectInput: this.injectInput,
            color: this.color,
            onlyBorderColor: this.onlyBorderColor,
            qrList: this.qrList,
            idIndex: this.idIndex,
        };
    }


    async performSave() {
        const response = await fetch('/api/quick-replies/save', {
            method: 'POST',
            headers: getRequestHeaders(),
            body: JSON.stringify(this),
        });

        if (response.ok) {
            this.rerender();
        } else {
            warn(`Failed to save Quick Reply Set: ${this.name}`);
            console.error('QR could not be saved', response);
        }
    }

    async delete() {
        const response = await fetch('/api/quick-replies/delete', {
            method: 'POST',
            headers: getRequestHeaders(),
            body: JSON.stringify(this),
        });

        if (response.ok) {
            this.unrender();
            const idx = QuickReplySet.list.indexOf(this);
            if (idx > -1) {
                QuickReplySet.list.splice(idx, 1);
                this.isDeleted = true;
            } else {
                warn(`Deleted Quick Reply Set was not found in the list of sets: ${this.name}`);
            }
        } else {
            warn(`Failed to delete Quick Reply Set: ${this.name}`);
        }
    }
}



---
File: /src/QuickReplySetLink.js
---

import { QuickReplySet } from './QuickReplySet.js';

export class QuickReplySetLink {
    static from(props) {
        props.set = QuickReplySet.get(props.set);
        /**@type {QuickReplySetLink}*/
        const instance = Object.assign(new this(), props);
        return instance;
    }




    /**@type {QuickReplySet}*/ set;
    /**@type {Boolean}*/ isVisible = true;

    /**@type {Number}*/ index;

    /**@type {Function}*/ onUpdate;
    /**@type {Function}*/ onRequestEditSet;
    /**@type {Function}*/ onDelete;

    /**@type {HTMLElement}*/ settingsDom;




    renderSettings(idx) {
        this.index = idx;
        const item = document.createElement('div'); {
            this.settingsDom = item;
            item.classList.add('qr--item');
            item.setAttribute('data-order', String(this.index));
            const drag = document.createElement('div'); {
                drag.classList.add('drag-handle');
                drag.classList.add('ui-sortable-handle');
                drag.textContent = '☰';
                item.append(drag);
            }
            const set = document.createElement('select'); {
                set.classList.add('qr--set');
                // fix for jQuery sortable breaking childrens' touch events
                set.addEventListener('touchstart', (evt)=>evt.stopPropagation());
                set.addEventListener('change', ()=>{
                    this.set = QuickReplySet.get(set.value);
                    this.update();
                });
                QuickReplySet.list.toSorted((a,b)=>a.name.toLowerCase().localeCompare(b.name.toLowerCase())).forEach(qrs=>{
                    const opt = document.createElement('option'); {
                        opt.value = qrs.name;
                        opt.textContent = qrs.name;
                        opt.selected = qrs == this.set;
                        set.append(opt);
                    }
                });
                item.append(set);
            }
            const visible = document.createElement('label'); {
                visible.classList.add('qr--visible');
                visible.title = 'Show buttons';
                const cb = document.createElement('input'); {
                    cb.type = 'checkbox';
                    cb.checked = this.isVisible;
                    cb.addEventListener('click', ()=>{
                        this.isVisible = cb.checked;
                        this.update();
                    });
                    visible.append(cb);
                }
                visible.append('Buttons');
                item.append(visible);
            }
            const edit = document.createElement('div'); {
                edit.classList.add('menu_button');
                edit.classList.add('menu_button_icon');
                edit.classList.add('fa-solid');
                edit.classList.add('fa-pencil');
                edit.title = 'Edit quick reply set';
                edit.addEventListener('click', ()=>this.requestEditSet());
                item.append(edit);
            }
            const del = document.createElement('div'); {
                del.classList.add('qr--del');
                del.classList.add('menu_button');
                del.classList.add('menu_button_icon');
                del.classList.add('fa-solid');
                del.classList.add('fa-trash-can');
                del.title = 'Remove quick reply set';
                del.addEventListener('click', ()=>this.delete());
                item.append(del);
            }
        }
        return this.settingsDom;
    }
    unrenderSettings() {
        this.settingsDom?.remove();
        this.settingsDom = null;
    }




    update() {
        if (this.onUpdate) {
            this.onUpdate(this);
        }
    }
    requestEditSet() {
        if (this.onRequestEditSet) {
            this.onRequestEditSet(this.set);
        }
    }
    delete() {
        this.unrenderSettings();
        if (this.onDelete) {
            this.onDelete();
        }
    }




    toJSON() {
        return {
            set: this.set.name,
            isVisible: this.isVisible,
        };
    }
}



---
File: /src/QuickReplySettings.js
---

import { chat_metadata, saveChatDebounced, saveSettingsDebounced } from '../../../../script.js';
import { extension_settings } from '../../../extensions.js';
import { QuickReplyConfig } from './QuickReplyConfig.js';

export class QuickReplySettings {
    static from(props) {
        props.config = QuickReplyConfig.from(props.config);
        const instance = Object.assign(new this(), props);
        instance.init();
        return instance;
    }




    /**@type {Boolean}*/ isEnabled = false;
    /**@type {Boolean}*/ isCombined = false;
    /**@type {Boolean}*/ isPopout = false;
    /**@type {Boolean}*/ showPopoutButton = true;
    /**@type {QuickReplyConfig}*/ config;
    /**@type {QuickReplyConfig}*/ _chatConfig;
    get chatConfig() {
        return this._chatConfig;
    }
    set chatConfig(value) {
        if (this._chatConfig != value) {
            this.unhookConfig(this._chatConfig);
            this._chatConfig = value;
            this.hookConfig(this._chatConfig);
        }
    }

    /**@type {Function}*/ onSave;
    /**@type {Function}*/ onRequestEditSet;




    init() {
        this.hookConfig(this.config);
        this.hookConfig(this.chatConfig);
    }

    hookConfig(config) {
        if (config) {
            config.onUpdate = ()=>this.save();
            config.onRequestEditSet = (qrs)=>this.requestEditSet(qrs);
        }
    }
    unhookConfig(config) {
        if (config) {
            config.onUpdate = null;
            config.onRequestEditSet = null;
        }
    }




    save() {
        extension_settings.quickReplyV2 = this.toJSON();
        saveSettingsDebounced();
        if (this.chatConfig) {
            chat_metadata.quickReply = this.chatConfig.toJSON();
            saveChatDebounced();
        }
        if (this.onSave) {
            this.onSave();
        }
    }

    requestEditSet(qrs) {
        if (this.onRequestEditSet) {
            this.onRequestEditSet(qrs);
        }
    }

    toJSON() {
        return {
            isEnabled: this.isEnabled,
            isCombined: this.isCombined,
            isPopout: this.isPopout,
            showPopoutButton: this.showPopoutButton,
            config: this.config,
        };
    }
}



---
File: /src/SlashCommandHandler.js
---

import { SlashCommand } from '../../../slash-commands/SlashCommand.js';
import { SlashCommandAbortController } from '../../../slash-commands/SlashCommandAbortController.js';
import { ARGUMENT_TYPE, SlashCommandArgument, SlashCommandNamedArgument } from '../../../slash-commands/SlashCommandArgument.js';
import { SlashCommandClosure } from '../../../slash-commands/SlashCommandClosure.js';
import { enumIcons } from '../../../slash-commands/SlashCommandCommonEnumsProvider.js';
import { SlashCommandDebugController } from '../../../slash-commands/SlashCommandDebugController.js';
import { SlashCommandEnumValue, enumTypes } from '../../../slash-commands/SlashCommandEnumValue.js';
import { SlashCommandParser } from '../../../slash-commands/SlashCommandParser.js';
import { SlashCommandScope } from '../../../slash-commands/SlashCommandScope.js';
import { isTrueBoolean } from '../../../utils.js';
// eslint-disable-next-line no-unused-vars
import { QuickReplyApi } from '../api/QuickReplyApi.js';
import { QuickReply } from './QuickReply.js';
import { QuickReplySet } from './QuickReplySet.js';

export class SlashCommandHandler {
    /**@type {QuickReplyApi}*/ api;




    constructor(/**@type {QuickReplyApi}*/api) {
        this.api = api;
    }




    init() {
        function getExecutionIcons(/**@type {QuickReply} */ qr) {
            let icons = '';
            if (qr.preventAutoExecute) icons += '🚫';
            if (qr.isHidden) icons += '👁️';
            if (qr.executeOnStartup) icons += '🚀';
            if (qr.executeOnUser) icons += enumIcons.user;
            if (qr.executeOnAi) icons += enumIcons.assistant;
            if (qr.executeOnChatChange) icons += '💬';
            if (qr.executeOnNewChat) icons += '🆕';
            if (qr.executeOnGroupMemberDraft) icons += enumIcons.group;
            return icons;
        }

        const localEnumProviders = {
            /** All quick reply sets, optionally filtering out sets that wer already used in the "set" named argument */
            qrSets: (executor) => QuickReplySet.list.filter(qrSet => qrSet.name != String(executor.namedArgumentList.find(x => x.name == 'set')?.value))
                .map(qrSet => new SlashCommandEnumValue(qrSet.name, null, enumTypes.enum, 'S')),

            /** All QRs inside a set, utilizing the "set" named argument */
            qrEntries: (executor) => QuickReplySet.get(String(executor.namedArgumentList.find(x => x.name == 'set')?.value))?.qrList.map(qr => {
                const icons = getExecutionIcons(qr);
                const message = `${qr.automationId ? `[${qr.automationId}]` : ''}${icons ? `[auto: ${icons}]` : ''} ${qr.title || qr.message}`.trim();
                return new SlashCommandEnumValue(qr.label, message, enumTypes.enum, enumIcons.qr);
            }) ?? [],

            /** All QRs inside a set, utilizing the "set" named argument, returns the QR's ID */
            qrIds: (executor) => QuickReplySet.get(String(executor.namedArgumentList.find(x => x.name == 'set')?.value))?.qrList.map(qr => {
                const icons = getExecutionIcons(qr);
                const message = `${qr.automationId ? `[${qr.automationId}]` : ''}${icons ? `[auto: ${icons}]` : ''} ${qr.title || qr.message}`.trim();
                return new SlashCommandEnumValue(qr.label, message, enumTypes.enum, enumIcons.qr, null, ()=>qr.id.toString(), true);
            }) ?? [],

            /** All QRs as a set.name string, to be able to execute, for example via the /run command */
            qrExecutables: () => {
                const globalSetList = this.api.settings.config.setList;
                const chatSetList = this.api.settings.chatConfig?.setList;

                const globalQrs = globalSetList.map(link => link.set.qrList.map(qr => ({ set: link.set, qr }))).flat();
                const chatQrs = chatSetList?.map(link => link.set.qrList.map(qr => ({ set: link.set, qr }))).flat() ?? [];
                const otherQrs = QuickReplySet.list.filter(set => !globalSetList.some(link => link.set.name === set.name && !chatSetList?.some(link => link.set.name === set.name)))
                    .map(set => set.qrList.map(qr => ({ set, qr }))).flat();

                return [
                    ...globalQrs.map(x => new SlashCommandEnumValue(`${x.set.name}.${x.qr.label}`, `[global] ${x.qr.title || x.qr.message}`, enumTypes.name, enumIcons.qr)),
                    ...chatQrs.map(x => new SlashCommandEnumValue(`${x.set.name}.${x.qr.label}`, `[chat] ${x.qr.title || x.qr.message}`, enumTypes.enum, enumIcons.qr)),
                    ...otherQrs.map(x => new SlashCommandEnumValue(`${x.set.name}.${x.qr.label}`, `${x.qr.title || x.qr.message}`, enumTypes.qr, enumIcons.qr)),
                ];
            },
        };

        window['qrEnumProviderExecutables'] = localEnumProviders.qrExecutables;

        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr',
            callback: (_, value) => this.executeQuickReplyByIndex(Number(value)),
            unnamedArgumentList: [
                new SlashCommandArgument(
                    'number', [ARGUMENT_TYPE.NUMBER], true,
                ),
            ],
            helpString: 'Activates the specified Quick Reply',
        }));
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qrset',
            callback: () => {
                toastr.warning('The command /qrset has been deprecated. Use /qr-set, /qr-set-on, and /qr-set-off instead.');
                return '';
            },
            helpString: '<strong>DEPRECATED</strong> – The command /qrset has been deprecated. Use /qr-set, /qr-set-on, and /qr-set-off instead.',
        }));
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-set',
            callback: (args, value) => {
                this.toggleGlobalSet(value, args);
                return '';
            },
            namedArgumentList: [
                new SlashCommandNamedArgument(
                    'visible', 'set visibility', [ARGUMENT_TYPE.BOOLEAN], false, false, 'true',
                ),
            ],
            unnamedArgumentList: [
                SlashCommandArgument.fromProps({
                    description: 'QR set name',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                }),
            ],
            helpString: 'Toggle global QR set',
        }));
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-set-on',
            callback: (args, value) => {
                this.addGlobalSet(value, args);
                return '';
            },
            namedArgumentList: [
                new SlashCommandNamedArgument(
                    'visible', 'set visibility', [ARGUMENT_TYPE.BOOLEAN], false, false, 'true',
                ),
            ],
            unnamedArgumentList: [
                SlashCommandArgument.fromProps({
                    description: 'QR set name',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                }),
            ],
            helpString: 'Activate global QR set',
        }));
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-set-off',
            callback: (_, value) => {
                this.removeGlobalSet(value);
                return '';
            },
            unnamedArgumentList: [
                SlashCommandArgument.fromProps({
                    description: 'QR set name',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                }),
            ],
            helpString: 'Deactivate global QR set',
        }));
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-chat-set',
            callback: (args, value) => {
                this.toggleChatSet(value, args);
                return '';
            },
            namedArgumentList: [
                new SlashCommandNamedArgument(
                    'visible', 'set visibility', [ARGUMENT_TYPE.BOOLEAN], false, false, 'true',
                ),
            ],
            unnamedArgumentList: [
                SlashCommandArgument.fromProps({
                    description: 'QR set name',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                }),
            ],
            helpString: 'Toggle chat QR set',
        }));

        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-chat-set-on',
            callback: (args, value) => {
                this.addChatSet(value, args);
                return '';
            },
            namedArgumentList: [
                new SlashCommandNamedArgument(
                    'visible', 'whether the QR set should be visible', [ARGUMENT_TYPE.BOOLEAN], false, false, 'true',
                ),
            ],
            unnamedArgumentList: [
                SlashCommandArgument.fromProps({
                    description: 'QR set name',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                }),
            ],
            helpString: 'Activate chat QR set',
        }));
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-chat-set-off',
            callback: (_, value) => {
                this.removeChatSet(value);
                return '';
            },
            unnamedArgumentList: [
                SlashCommandArgument.fromProps({
                    description: 'QR set name',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                }),
            ],
            helpString: 'Deactivate chat QR set',
        }));
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-set-list',
            callback: (_, value) => JSON.stringify(this.listSets(value ?? 'all')),
            returns: 'list of QR sets',
            namedArgumentList: [],
            unnamedArgumentList: [
                new SlashCommandArgument(
                    'set type', [ARGUMENT_TYPE.STRING], false, false, 'all', ['all', 'global', 'chat'],
                ),
            ],
            helpString: 'Gets a list of the names of all quick reply sets.',
        }));
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-list',
            callback: (_, value) => {
                return JSON.stringify(this.listQuickReplies(value));
            },
            returns: 'list of QRs',
            namedArgumentList: [],
            unnamedArgumentList: [
                SlashCommandArgument.fromProps({
                    description: 'QR set name',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                }),
            ],
            helpString: 'Gets a list of the names of all quick replies in this quick reply set.',
        }));

        const qrArgs = [
            SlashCommandNamedArgument.fromProps({
                name: 'set',
                description: 'name of the QR set, e.g., set=PresetName1',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: true,
                enumProvider: localEnumProviders.qrSets,
            }),
            SlashCommandNamedArgument.fromProps({
                name: 'label',
                description: 'text on the button, e.g., label=MyButton',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
                enumProvider: localEnumProviders.qrEntries,
            }),
            SlashCommandNamedArgument.fromProps({
                name: 'icon',
                description: 'icon to show on the button, e.g., icon=fa-pencil',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: false,
            }),
            SlashCommandNamedArgument.fromProps({
                name: 'showlabel',
                description: 'whether to show the label even when an icon is assigned, e.g., icon=fa-pencil showlabel=true',
                typeList: [ARGUMENT_TYPE.BOOLEAN],
                isRequired: false,
            }),
            new SlashCommandNamedArgument('hidden', 'whether the button should be hidden, e.g., hidden=true', [ARGUMENT_TYPE.BOOLEAN], false, false, 'false'),
            new SlashCommandNamedArgument('startup', 'auto execute on app startup, e.g., startup=true', [ARGUMENT_TYPE.BOOLEAN], false, false, 'false'),
            new SlashCommandNamedArgument('user', 'auto execute on user message, e.g., user=true', [ARGUMENT_TYPE.BOOLEAN], false, false, 'false'),
            new SlashCommandNamedArgument('bot', 'auto execute on AI message, e.g., bot=true', [ARGUMENT_TYPE.BOOLEAN], false, false, 'false'),
            new SlashCommandNamedArgument('load', 'auto execute on chat load, e.g., load=true', [ARGUMENT_TYPE.BOOLEAN], false, false, 'false'),
            new SlashCommandNamedArgument('new', 'auto execute on new chat, e.g., new=true', [ARGUMENT_TYPE.BOOLEAN], false, false, 'false'),
            new SlashCommandNamedArgument('group', 'auto execute on group member selection, e.g., group=true', [ARGUMENT_TYPE.BOOLEAN], false, false, 'false'),
            new SlashCommandNamedArgument('title', 'title / tooltip to be shown on button, e.g., title="My Fancy Button"', [ARGUMENT_TYPE.STRING], false),
        ];
        const qrUpdateArgs = [
            new SlashCommandNamedArgument('newlabel', 'new text for the button', [ARGUMENT_TYPE.STRING], false),
            SlashCommandNamedArgument.fromProps({
                name: 'id',
                description: 'numeric ID of the QR, e.g., id=42',
                typeList: [ARGUMENT_TYPE.NUMBER],
                isRequired: false,
                enumProvider: localEnumProviders.qrIds,
            }),
        ];

        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-create',
            callback: (args, message) => {
                this.createQuickReply(args, message);
                return '';
            },
            namedArgumentList: qrArgs,
            unnamedArgumentList: [
                new SlashCommandArgument(
                    'command', [ARGUMENT_TYPE.STRING], true,
                ),
            ],
            helpString: `
                <div>Creates a new Quick Reply.</div>
                <div>
                    <strong>Example:</strong>
                    <ul>
                        <li>
                            <pre><code>/qr-create set=MyPreset label=MyButton /echo 123</code></pre>
                        </li>
                    </ul>
                </div>
            `,
        }));
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-get',
            callback: (args, _) => {
                return this.getQuickReply(args);
            },
            namedArgumentList: [
                SlashCommandNamedArgument.fromProps({
                    name: 'set',
                    description: 'name of the QR set, e.g., set=PresetName1',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                }),
                SlashCommandNamedArgument.fromProps({
                    name: 'label',
                    description: 'text on the button, e.g., label=MyButton',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: false,
                    enumProvider: localEnumProviders.qrEntries,
                }),
                SlashCommandNamedArgument.fromProps({
                    name: 'id',
                    description: 'numeric ID of the QR, e.g., id=42',
                    typeList: [ARGUMENT_TYPE.NUMBER],
                    isRequired: false,
                    enumProvider: localEnumProviders.qrIds,
                }),
            ],
            returns: 'a dictionary with all the QR\'s properties',
            helpString: `
                <div>Get a Quick Reply's properties.</div>
                <div>
                    <strong>Examples:</strong>
                    <ul>
                        <li>
                            <pre><code>/qr-get set=MyPreset label=MyButton | /echo</code></pre>
                            <pre><code>/qr-get set=MyPreset id=42 | /echo</code></pre>
                        </li>
                    </ul>
                </div>
            `,
        }));
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-update',
            callback: (args, message) => {
                this.updateQuickReply(args, message);
                return '';
            },
            returns: 'updated quick reply',
            namedArgumentList: [...qrUpdateArgs, ...qrArgs.map(it=>{
                if (it.name == 'label') {
                    const clone = SlashCommandNamedArgument.fromProps(it);
                    clone.isRequired = false;
                    return clone;
                }
                return it;
            })],
            unnamedArgumentList: [
                new SlashCommandArgument('command', [ARGUMENT_TYPE.STRING]),
            ],
            helpString: `
                <div>
                    Updates Quick Reply.
                </div>
                <div>
                    <strong>Example:</strong>
                    <ul>
                        <li>
                            <pre><code>/qr-update set=MyPreset label=MyButton newlabel=MyRenamedButton /echo 123</code></pre>
                        </li>
                    </ul>
                </div>
            `,
        }));
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-delete',
            callback: (args, name) => {
                this.deleteQuickReply(args, name);
                return '';
            },
            namedArgumentList: [
                SlashCommandNamedArgument.fromProps({
                    name: 'set',
                    description: 'QR set name',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                }),
                SlashCommandNamedArgument.fromProps({
                    name: 'label',
                    description: 'Quick Reply label',
                    typeList: [ARGUMENT_TYPE.STRING],
                    enumProvider: localEnumProviders.qrEntries,
                }),
                SlashCommandNamedArgument.fromProps({
                    name: 'id',
                    description: 'numeric ID of the QR, e.g., id=42',
                    typeList: [ARGUMENT_TYPE.NUMBER],
                    enumProvider: localEnumProviders.qrIds,
                }),
            ],
            unnamedArgumentList: [
                SlashCommandArgument.fromProps({
                    description: 'label',
                    typeList: [ARGUMENT_TYPE.STRING],
                    enumProvider: localEnumProviders.qrEntries,
                }),
            ],
            helpString: 'Deletes a Quick Reply from the specified set. (Label must be provided via named or unnamed argument)',
        }));
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-contextadd',
            callback: (args, name) => {
                this.createContextItem(args, name);
                return '';
            },
            namedArgumentList: [
                SlashCommandNamedArgument.fromProps({
                    name: 'set',
                    description: 'QR set name',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                }),
                SlashCommandNamedArgument.fromProps({
                    name: 'label',
                    description: 'Quick Reply label',
                    typeList: [ARGUMENT_TYPE.STRING],
                    enumProvider: localEnumProviders.qrEntries,
                }),
                SlashCommandNamedArgument.fromProps({
                    name: 'id',
                    description: 'numeric ID of the QR, e.g., id=42',
                    typeList: [ARGUMENT_TYPE.NUMBER],
                    enumProvider: localEnumProviders.qrIds,
                }),
                new SlashCommandNamedArgument(
                    'chain', 'boolean', [ARGUMENT_TYPE.BOOLEAN], false, false, 'false',
                ),
            ],
            unnamedArgumentList: [
                SlashCommandArgument.fromProps({
                    description: 'QR set name',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                }),
            ],
            helpString: `
                <div>
                    Add context menu preset to a QR.
                </div>
                <div>
                    <strong>Example:</strong>
                    <ul>
                        <li>
                            <pre><code>/qr-contextadd set=MyPreset label=MyButton chain=true MyOtherPreset</code></pre>
                        </li>
                    </ul>
                </div>
            `,
        }));
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-contextdel',
            callback: (args, name) => {
                this.deleteContextItem(args, name);
                return '';
            },
            namedArgumentList: [
                SlashCommandNamedArgument.fromProps({
                    name: 'set',
                    description: 'QR set name',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                }),
                SlashCommandNamedArgument.fromProps({
                    name: 'label',
                    description: 'Quick Reply label',
                    typeList: [ARGUMENT_TYPE.STRING],
                    enumProvider: localEnumProviders.qrEntries,
                }),
                SlashCommandNamedArgument.fromProps({
                    name: 'id',
                    description: 'numeric ID of the QR, e.g., id=42',
                    typeList: [ARGUMENT_TYPE.NUMBER],
                    enumProvider: localEnumProviders.qrIds,
                }),
            ],
            unnamedArgumentList: [
                SlashCommandArgument.fromProps({
                    description: 'QR set name',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                }),
            ],
            helpString: `
                <div>
                    Remove context menu preset from a QR.
                </div>
                <div>
                    <strong>Example:</strong>
                    <ul>
                        <li>
                            <pre><code>/qr-contextdel set=MyPreset label=MyButton MyOtherPreset</code></pre>
                        </li>
                    </ul>
                </div>
            `,
        }));
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-contextclear',
            callback: (args, label) => {
                this.clearContextMenu(args, label);
                return '';
            },
            namedArgumentList: [
                SlashCommandNamedArgument.fromProps({
                    name: 'set',
                    description: 'QR set name',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                }),
                SlashCommandNamedArgument.fromProps({
                    name: 'id',
                    description: 'numeric ID of the QR, e.g., id=42',
                    typeList: [ARGUMENT_TYPE.NUMBER],
                    enumProvider: localEnumProviders.qrIds,
                }),
            ],
            unnamedArgumentList: [
                SlashCommandArgument.fromProps({
                    description: 'Quick Reply label',
                    typeList: [ARGUMENT_TYPE.STRING],
                    enumProvider: localEnumProviders.qrEntries,
                }),
            ],
            helpString: `
                <div>
                    Remove all context menu presets from a QR.
                </div>
                <div>
                    <strong>Example:</strong>
                    <ul>
                        <li>
                            <pre><code>/qr-contextclear set=MyPreset MyButton</code></pre>
                        </li>
                    </ul>
                </div>
            `,
        }));

        const presetArgs = [
            new SlashCommandNamedArgument('nosend', 'disable send / insert in user input (invalid for slash commands)', [ARGUMENT_TYPE.BOOLEAN], false),
            new SlashCommandNamedArgument('before', 'place QR before user input', [ARGUMENT_TYPE.BOOLEAN], false),
            new SlashCommandNamedArgument('inject', 'inject user input automatically (if disabled use {{input}})', [ARGUMENT_TYPE.BOOLEAN], false),
        ];
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-set-create',
            callback: async (args, name) => {
                await this.createSet(name, args);
                return '';
            },
            aliases: ['qr-presetadd'],
            namedArgumentList: presetArgs,
            unnamedArgumentList: [
                SlashCommandArgument.fromProps({
                    description: 'QR set name',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                    forceEnum: false,
                }),
            ],
            helpString: `
                <div>
                    Create a new preset (overrides existing ones).
                </div>
                <div>
                    <strong>Example:</strong>
                    <ul>
                        <li>
                            <pre><code>/qr-set-add MyNewPreset</code></pre>
                        </li>
                    </ul>
                </div>
            `,
        }));

        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-set-update',
            callback: async (args, name) => {
                await this.updateSet(name, args);
                return '';
            },
            aliases: ['qr-presetupdate'],
            namedArgumentList: presetArgs,
            unnamedArgumentList: [
                SlashCommandArgument.fromProps({
                    description: 'QR set name',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                }),
            ],
            helpString: `
                <div>
                    Update an existing preset.
                </div>
                <div>
                    <strong>Example:</strong>
                    <pre><code>/qr-set-update enabled=false MyPreset</code></pre>
                </div>
            `,
        }));
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-set-delete',
            callback: async (_, name) => {
                await this.deleteSet(name);
                return '';
            },
            aliases: ['qr-presetdelete'],
            unnamedArgumentList: [
                SlashCommandArgument.fromProps({
                    description: 'QR set name',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: true,
                    enumProvider: localEnumProviders.qrSets,
                }),
            ],
            helpString: `
                <div>
                    Delete an existing preset.
                </div>
                <div>
                    <strong>Example:</strong>
                    <pre><code>/qr-set-delete MyPreset</code></pre>
                </div>
            `,
        }));

        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'qr-arg',
            callback: ({ _scope }, [key, value]) => {
                _scope.setMacro(`arg::${key}`, value, key.includes('*'));
                return '';
            },
            unnamedArgumentList: [
                SlashCommandArgument.fromProps({ description: 'argument name',
                    typeList: ARGUMENT_TYPE.STRING,
                    isRequired: true,
                }),
                SlashCommandArgument.fromProps({ description: 'argument value',
                    typeList: [ARGUMENT_TYPE.STRING, ARGUMENT_TYPE.NUMBER, ARGUMENT_TYPE.BOOLEAN, ARGUMENT_TYPE.LIST, ARGUMENT_TYPE.DICTIONARY],
                    isRequired: true,
                }),
            ],
            splitUnnamedArgument: true,
            splitUnnamedArgumentCount: 2,
            helpString: `
                <div>
                    Set a fallback value for a Quick Reply argument.
                </div>
                <div>
                    <strong>Example:</strong>
                    <pre><code>/qr-arg x foo |\n/echo {{arg::x}}</code></pre>
                </div>
            `,
        }));

        SlashCommandParser.addCommandObject(SlashCommand.fromProps({ name: 'import',
            /**
             *
             * @param {{_scope:SlashCommandScope, _abortController:SlashCommandAbortController, _debugController:SlashCommandDebugController, from:string}} args
             * @param {string} value
             */
            callback: (args, value) => {
                if (!args.from) throw new Error('/import requires from= to be set.');
                if (!value) throw new Error('/import requires the unnamed argument to be set.');
                let qr = [...this.api.listGlobalSets(), ...this.api.listChatSets()]
                    .map(it=>this.api.getSetByName(it)?.qrList ?? [])
                    .flat()
                    .find(it=>it.label == args.from)
                ;
                if (!qr) {
                    let [setName, ...qrNameParts] = args.from.split('.');
                    let qrName = qrNameParts.join('.');
                    let qrs = QuickReplySet.get(setName);
                    if (qrs) {
                        qr = qrs.qrList.find(it=>it.label == qrName);
                    }
                }
                if (qr) {
                    const parser = new SlashCommandParser();
                    const closure = parser.parse(qr.message, true, [], args._abortController, args._debugController);
                    if (args._debugController) {
                        closure.source = args.from;
                    }
                    const testCandidates = (executor)=>{
                        return (
                            executor.namedArgumentList.find(arg=>arg.name == 'key')
                            && executor.unnamedArgumentList.length > 0
                            && executor.unnamedArgumentList[0].value instanceof SlashCommandClosure
                        ) || (
                            !executor.namedArgumentList.find(arg=>arg.name == 'key')
                            && executor.unnamedArgumentList.length > 1
                            && executor.unnamedArgumentList[1].value instanceof SlashCommandClosure
                        );
                    };
                    const candidates = closure.executorList
                        .filter(executor=>['let', 'var'].includes(executor.command.name))
                        .filter(testCandidates)
                        .map(executor=>({
                            key: executor.namedArgumentList.find(arg=>arg.name == 'key')?.value ?? executor.unnamedArgumentList[0].value,
                            value: executor.unnamedArgumentList[executor.namedArgumentList.find(arg=>arg.name == 'key') ? 0 : 1].value,
                        }))
                    ;
                    for (let i = 0; i < value.length; i++) {
                        const srcName = value[i];
                        let dstName = srcName;
                        if (i + 2 < value.length && value[i + 1] == 'as') {
                            dstName = value[i + 2];
                            i += 2;
                        }
                        const pick = candidates.find(it=>it.key == srcName);
                        if (!pick) throw new Error(`No scoped closure named "${srcName}" found in "${args.from}"`);
                        if (args._scope.existsVariableInScope(dstName)) {
                            args._scope.setVariable(dstName, pick.value);
                        } else {
                            args._scope.letVariable(dstName, pick.value);
                        }
                    }
                } else {
                    throw new Error(`No Quick Reply found for "${name}".`);
                }
                return '';
            },
            namedArgumentList: [
                SlashCommandNamedArgument.fromProps({ name: 'from',
                    description: 'Quick Reply to import from (QRSet.QRLabel)',
                    typeList: ARGUMENT_TYPE.STRING,
                    isRequired: true,
                }),
            ],
            unnamedArgumentList: [
                SlashCommandArgument.fromProps({ description: 'what to import (x or x as y)',
                    acceptsMultiple: true,
                    typeList: ARGUMENT_TYPE.STRING,
                    isRequired: true,
                }),
            ],
            splitUnnamedArgument: true,
            helpString: `
                <div>
                    Import one or more closures from another Quick Reply.
                </div>
                <div>
                    Only imports closures that are directly assigned a scoped variable via <code>/let</code> or <code>/var</code>.
                </div>
                <div>
                    <strong>Examples:</strong>
                    <ul>
                        <li><pre><code>/import from=LibraryQrSet.FooBar foo |\n/:foo</code></pre></li>
                        <li><pre><code>/import from=LibraryQrSet.FooBar\n\tfoo\n\tbar\n|\n/:foo |\n/:bar</code></pre></li>
                        <li><pre><code>/import from=LibraryQrSet.FooBar\n\tfoo as x\n\tbar as y\n|\n/:x |\n/:y</code></pre></li>
                    </ul>
                </div>
            `,
        }));
    }




    getSetByName(name) {
        const set = this.api.getSetByName(name);
        if (!set) {
            toastr.error(`No Quick Reply Set with the name "${name}" could be found.`);
        }
        return set;
    }

    getQrByLabel(setName, label) {
        const qr = this.api.getQrByLabel(setName, label);
        if (!qr) {
            toastr.error(`No Quick Reply with the label "${label}" could be found in the set "${setName}"`);
        }
        return qr;
    }




    async executeQuickReplyByIndex(idx) {
        try {
            return await this.api.executeQuickReplyByIndex(idx);
        } catch (ex) {
            toastr.error(ex.message);
        }
    }


    toggleGlobalSet(name, args = {}) {
        try {
            this.api.toggleGlobalSet(name, isTrueBoolean(args.visible ?? 'true'));
        } catch (ex) {
            toastr.error(ex.message);
        }
    }
    addGlobalSet(name, args = {}) {
        try {
            this.api.addGlobalSet(name, isTrueBoolean(args.visible ?? 'true'));
        } catch (ex) {
            toastr.error(ex.message);
        }
    }
    removeGlobalSet(name) {
        try {
            this.api.removeGlobalSet(name);
        } catch (ex) {
            toastr.error(ex.message);
        }
    }


    toggleChatSet(name, args = {}) {
        try {
            this.api.toggleChatSet(name, isTrueBoolean(args.visible ?? 'true'));
        } catch (ex) {
            toastr.error(ex.message);
        }
    }
    addChatSet(name, args = {}) {
        try {
            this.api.addChatSet(name, isTrueBoolean(args.visible ?? 'true'));
        } catch (ex) {
            toastr.error(ex.message);
        }
    }
    removeChatSet(name) {
        try {
            this.api.removeChatSet(name);
        } catch (ex) {
            toastr.error(ex.message);
        }
    }


    createQuickReply(args, message) {
        try {
            this.api.createQuickReply(
                args.set ?? '',
                args.label ?? '',
                {
                    icon: args.icon,
                    showLabel: args.showlabel === undefined ? undefined : isTrueBoolean(args.showlabel),
                    message: message ?? '',
                    title: args.title,
                    isHidden: isTrueBoolean(args.hidden),
                    executeOnStartup: isTrueBoolean(args.startup),
                    executeOnUser: isTrueBoolean(args.user),
                    executeOnAi: isTrueBoolean(args.bot),
                    executeOnChatChange: isTrueBoolean(args.load),
                    executeOnNewChat: isTrueBoolean(args.new),
                    executeOnGroupMemberDraft: isTrueBoolean(args.group),
                    automationId: args.automationId ?? '',
                },
            );
        } catch (ex) {
            toastr.error(ex.message);
        }
    }
    getQuickReply(args) {
        try {
            return JSON.stringify(this.api.getQrByLabel(args.set, args.id !== undefined ? Number(args.id) : args.label));
        } catch (ex) {
            toastr.error(ex.message);
        }
    }
    updateQuickReply(args, message) {
        try {
            this.api.updateQuickReply(
                args.set ?? '',
                args.id !== undefined ? Number(args.id) : (args.label ?? ''),
                {
                    icon: args.icon,
                    showLabel: args.showlabel === undefined ? undefined : isTrueBoolean(args.showlabel),
                    newLabel: args.newlabel,
                    message: (message ?? '').trim().length > 0 ? message : undefined,
                    title: args.title,
                    isHidden: args.hidden === undefined ? undefined : isTrueBoolean(args.hidden),
                    executeOnStartup: args.startup === undefined ? undefined : isTrueBoolean(args.startup),
                    executeOnUser: args.user === undefined ? undefined : isTrueBoolean(args.user),
                    executeOnAi: args.bot === undefined ? undefined : isTrueBoolean(args.bot),
                    executeOnChatChange: args.load === undefined ? undefined : isTrueBoolean(args.load),
                    executeOnGroupMemberDraft: args.group === undefined ? undefined : isTrueBoolean(args.group),
                    executeOnNewChat: args.new === undefined ? undefined : isTrueBoolean(args.new),
                    automationId: args.automationId ?? '',
                },
            );
        } catch (ex) {
            toastr.error(ex.message);
        }
    }
    deleteQuickReply(args, label) {
        try {
            this.api.deleteQuickReply(args.set, args.id !== undefined ? Number(args.id) : (args.label ?? label));
        } catch (ex) {
            toastr.error(ex.message);
        }
    }


    createContextItem(args, name) {
        try {
            this.api.createContextItem(
                args.set,
                args.label,
                name,
                isTrueBoolean(args.chain),
            );
        }  catch (ex) {
            toastr.error(ex.message);
        }
    }
    deleteContextItem(args, name) {
        try {
            this.api.deleteContextItem(args.set, args.label, name);
        }  catch (ex) {
            toastr.error(ex.message);
        }
    }
    clearContextMenu(args, label) {
        try {
            this.api.clearContextMenu(args.set, args.label ?? label);
        } catch (ex) {
            toastr.error(ex.message);
        }
    }


    async createSet(name, args) {
        try {
            await this.api.createSet(
                args.name ?? name ?? '',
                {
                    disableSend: isTrueBoolean(args.nosend),
                    placeBeforeInput: isTrueBoolean(args.before),
                    injectInput: isTrueBoolean(args.inject),
                },
            );
        } catch (ex) {
            toastr.error(ex.message);
        }
    }
    async updateSet(name, args) {
        try {
            await this.api.updateSet(
                args.name ?? name ?? '',
                {
                    disableSend: args.nosend !== undefined ? isTrueBoolean(args.nosend) : undefined,
                    placeBeforeInput: args.before !== undefined ? isTrueBoolean(args.before) : undefined,
                    injectInput: args.inject !== undefined ? isTrueBoolean(args.inject) : undefined,
                },
            );
        } catch (ex) {
            toastr.error(ex.message);
        }
    }
    async deleteSet(name) {
        try {
            await this.api.deleteSet(name ?? '');
        } catch (ex) {
            toastr.error(ex.message);
        }
    }

    listSets(source) {
        try {
            switch (source) {
                case 'global':
                    return this.api.listGlobalSets();
                case 'chat':
                    return this.api.listChatSets();
                default:
                    return this.api.listSets();
            }
        } catch (ex) {
            toastr.error(ex.message);
        }
    }
    listQuickReplies(name) {
        try {
            return this.api.listQuickReplies(name);
        } catch (ex) {
            toastr.error(ex.message);
        }
    }
}



---
File: /index.js
---

import { chat, chat_metadata, eventSource, event_types, getRequestHeaders } from '../../../script.js';
import { extension_settings } from '../../extensions.js';
import { QuickReplyApi } from './api/QuickReplyApi.js';
import { AutoExecuteHandler } from './src/AutoExecuteHandler.js';
import { QuickReply } from './src/QuickReply.js';
import { QuickReplyConfig } from './src/QuickReplyConfig.js';
import { QuickReplySet } from './src/QuickReplySet.js';
import { QuickReplySettings } from './src/QuickReplySettings.js';
import { SlashCommandHandler } from './src/SlashCommandHandler.js';
import { ButtonUi } from './src/ui/ButtonUi.js';
import { SettingsUi } from './src/ui/SettingsUi.js';




const _VERBOSE = true;
export const debug = (...msg) => _VERBOSE ? console.debug('[QR2]', ...msg) : null;
export const log = (...msg) => _VERBOSE ? console.log('[QR2]', ...msg) : null;
export const warn = (...msg) => _VERBOSE ? console.warn('[QR2]', ...msg) : null;
/**
 * Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since the last time the debounced function was invoked.
 * @param {Function} func The function to debounce.
 * @param {Number} [timeout=300] The timeout in milliseconds.
 * @returns {Function} The debounced function.
 */
export function debounceAsync(func, timeout = 300) {
    let timer;
    /**@type {Promise}*/
    let debouncePromise;
    /**@type {Function}*/
    let debounceResolver;
    return (...args) => {
        clearTimeout(timer);
        if (!debouncePromise) {
            debouncePromise = new Promise(resolve => {
                debounceResolver = resolve;
            });
        }
        timer = setTimeout(() => {
            debounceResolver(func.apply(this, args));
            debouncePromise = null;
        }, timeout);
        return debouncePromise;
    };
}


const defaultConfig = {
    setList: [{
        set: 'Default',
        isVisible: true,
    }],
};

const defaultSettings = {
    isEnabled: false,
    isCombined: false,
    config: defaultConfig,
};


/** @type {Boolean}*/
let isReady = false;
/** @type {Function[]}*/
let executeQueue = [];
/** @type {QuickReplySettings}*/
let settings;
/** @type {SettingsUi} */
let manager;
/** @type {ButtonUi} */
let buttons;
/** @type {AutoExecuteHandler} */
let autoExec;
/** @type {QuickReplyApi} */
export let quickReplyApi;




const loadSets = async () => {
    const response = await fetch('/api/settings/get', {
        method: 'POST',
        headers: getRequestHeaders(),
        body: JSON.stringify({}),
    });

    if (response.ok) {
        const setList = (await response.json()).quickReplyPresets ?? [];
        for (const set of setList) {
            if (set.version !== 2) {
                // migrate old QR set
                set.version = 2;
                set.disableSend = set.quickActionEnabled ?? false;
                set.placeBeforeInput = set.placeBeforeInputEnabled ?? false;
                set.injectInput = set.AutoInputInject ?? false;
                set.qrList = set.quickReplySlots.map((slot,idx)=>{
                    const qr = {};
                    qr.id = idx + 1;
                    qr.label = slot.label ?? '';
                    qr.title = slot.title ?? '';
                    qr.message = slot.mes ?? '';
                    qr.isHidden = slot.hidden ?? false;
                    qr.executeOnStartup = slot.autoExecute_appStartup ?? false;
                    qr.executeOnUser = slot.autoExecute_userMessage ?? false;
                    qr.executeOnAi = slot.autoExecute_botMessage ?? false;
                    qr.executeOnChatChange = slot.autoExecute_chatLoad ?? false;
                    qr.executeOnGroupMemberDraft = slot.autoExecute_groupMemberDraft ?? false;
                    qr.executeOnNewChat = slot.autoExecute_newChat ?? false;
                    qr.automationId = slot.automationId ?? '';
                    qr.contextList = (slot.contextMenu ?? []).map(it=>({
                        set: it.preset,
                        isChained: it.chain,
                    }));
                    return qr;
                });
            }
            if (set.version == 2) {
                QuickReplySet.list.push(QuickReplySet.from(JSON.parse(JSON.stringify(set))));
            }
        }
        // need to load QR lists after all sets are loaded to be able to resolve context menu entries
        setList.forEach((set, idx)=>{
            QuickReplySet.list[idx].qrList = set.qrList.map(it=>QuickReply.from(it));
            QuickReplySet.list[idx].init();
        });
        log('sets: ', QuickReplySet.list);
    }
};

const loadSettings = async () => {
    if (!extension_settings.quickReplyV2) {
        if (!extension_settings.quickReply) {
            extension_settings.quickReplyV2 = defaultSettings;
        } else {
            extension_settings.quickReplyV2 = {
                isEnabled: extension_settings.quickReply.quickReplyEnabled ?? false,
                isCombined: false,
                isPopout: false,
                config: {
                    setList: [{
                        set: extension_settings.quickReply.selectedPreset ?? extension_settings.quickReply.name ?? 'Default',
                        isVisible: true,
                    }],
                },
            };
        }
    }
    try {
        settings = QuickReplySettings.from(extension_settings.quickReplyV2);
    } catch (ex) {
        settings = QuickReplySettings.from(defaultSettings);
    }
};

const executeIfReadyElseQueue = async (functionToCall, args) => {
    if (isReady) {
        log('calling', { functionToCall, args });
        await functionToCall(...args);
    } else {
        log('queueing', { functionToCall, args });
        executeQueue.push(async()=>await functionToCall(...args));
    }
};




const init = async () => {
    await loadSets();
    await loadSettings();
    log('settings: ', settings);

    manager = new SettingsUi(settings);
    document.querySelector('#qr_container').append(await manager.render());

    buttons = new ButtonUi(settings);
    buttons.show();
    settings.onSave = ()=>buttons.refresh();

    window['executeQuickReplyByName'] = async(name, args = {}, options = {}) => {
        let qr = [...settings.config.setList, ...(settings.chatConfig?.setList ?? [])]
            .map(it=>it.set.qrList)
            .flat()
            .find(it=>it.label == name)
            ;
        if (!qr) {
            let [setName, ...qrName] = name.split('.');
            qrName = qrName.join('.');
            let qrs = QuickReplySet.get(setName);
            if (qrs) {
                qr = qrs.qrList.find(it=>it.label == qrName);
            }
        }
        if (qr && qr.onExecute) {
            return await qr.execute(args, false, true, options);
        } else {
            throw new Error(`No Quick Reply found for "${name}".`);
        }
    };

    quickReplyApi = new QuickReplyApi(settings, manager);
    const slash = new SlashCommandHandler(quickReplyApi);
    slash.init();
    autoExec = new AutoExecuteHandler(settings);

    eventSource.on(event_types.APP_READY, async()=>await finalizeInit());

    window['quickReplyApi'] = quickReplyApi;
};
const finalizeInit = async () => {
    debug('executing startup');
    await autoExec.handleStartup();
    debug('/executing startup');

    debug(`executing queue (${executeQueue.length} items)`);
    while (executeQueue.length > 0) {
        const func = executeQueue.shift();
        await func();
    }
    debug('/executing queue');
    isReady = true;
    debug('READY');
};
await init();

const onChatChanged = async (chatIdx) => {
    log('CHAT_CHANGED', chatIdx);
    if (chatIdx) {
        settings.chatConfig = QuickReplyConfig.from(chat_metadata.quickReply ?? {});
    } else {
        settings.chatConfig = null;
    }
    manager.rerender();
    buttons.refresh();

    await autoExec.handleChatChanged();
};
eventSource.on(event_types.CHAT_CHANGED, (...args)=>executeIfReadyElseQueue(onChatChanged, args));

const onUserMessage = async () => {
    await autoExec.handleUser();
};
eventSource.makeFirst(event_types.USER_MESSAGE_RENDERED, (...args)=>executeIfReadyElseQueue(onUserMessage, args));

const onAiMessage = async (messageId) => {
    if (['...'].includes(chat[messageId]?.mes)) {
        log('QR auto-execution suppressed for swiped message');
        return;
    }

    await autoExec.handleAi();
};
eventSource.makeFirst(event_types.CHARACTER_MESSAGE_RENDERED, (...args)=>executeIfReadyElseQueue(onAiMessage, args));

const onGroupMemberDraft = async () => {
    await autoExec.handleGroupMemberDraft();
};
eventSource.on(event_types.GROUP_MEMBER_DRAFTED, (...args) => executeIfReadyElseQueue(onGroupMemberDraft, args));

const onWIActivation = async (entries) => {
    await autoExec.handleWIActivation(entries);
};
eventSource.on(event_types.WORLD_INFO_ACTIVATED, (...args) => executeIfReadyElseQueue(onWIActivation, args));

const onNewChat = async () => {
    await autoExec.handleNewChat();
};
eventSource.on(event_types.CHAT_CREATED, (...args) => executeIfReadyElseQueue(onNewChat, args));



---
File: /manifest.json
---

{
    "display_name": "Quick Replies",
    "loading_order": 12,
    "requires": [],
    "optional": [],
    "js": "index.js",
    "css": "style.css",
    "author": "RossAscends#1779",
    "version": "2.0.0",
    "homePage": "https://github.com/SillyTavern/SillyTavern"
}



---
File: /style.css
---

@keyframes qr--success {
  0%,
  100% {
    color: var(--SmartThemeBodyColor);
  }
  25%,
  75% {
    color: #51a351;
  }
}
.qr--success {
  animation-name: qr--success;
  animation-duration: 3s;
  animation-timing-function: linear;
  animation-delay: 0s;
  animation-iteration-count: 1;
}
#qr--bar {
  outline: none;
  margin: 0;
  transition: 0.3s;
  opacity: 0.7;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  max-width: 100%;
  overflow-x: auto;
  order: 1;
  position: relative;
}
#qr--bar > #qr--popoutTrigger {
  position: absolute;
  right: 0.25em;
  top: 0;
}

/*hide QR popout for mobile*/
@media screen and (max-width: 1000px) {
  #qr--bar > #qr--popoutTrigger {
 display:none;
  }
}

#qr--bar.popoutVisible {
  padding-right: 2.5em;
}
#qr--popout {
  display: flex;
  flex-direction: column;
  padding: 0;
  z-index: 31;
}
#qr--popout > .qr--header {
  flex: 0 0 auto;
  height: 2em;
  position: relative;
}
#qr--popout > .qr--header > .qr--controls > .qr--close {
  height: 15px;
  aspect-ratio: 1 / 1;
  font-size: 20px;
  opacity: 0.5;
  transition: all 250ms;
}

#qr--popout > .qr--body {
  overflow-y: auto;
}
#qr--bar > .qr--buttons,
#qr--popout > .qr--body > .qr--buttons {
  --qr--color: transparent;
  margin: 0;
  padding: 0;
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 5px;
  width: 100%;
}
#qr--bar > .qr--buttons.qr--color,
#qr--popout > .qr--body > .qr--buttons.qr--color {
  background-color: var(--qr--color);
}
#qr--bar > .qr--buttons.qr--borderColor,
#qr--popout > .qr--body > .qr--buttons.qr--borderColor {
  background-color: transparent;
  border-left: 5px solid var(--qr--color);
  border-right: 5px solid var(--qr--color);
}
#qr--bar > .qr--buttons:has(.qr--buttons.qr--color),
#qr--popout > .qr--body > .qr--buttons:has(.qr--buttons.qr--color) {
  margin: 5px;
}
#qr--bar > .qr--buttons > .qr--buttons,
#qr--popout > .qr--body > .qr--buttons > .qr--buttons {
  display: contents;
}
#qr--bar > .qr--buttons > .qr--buttons.qr--color .qr--button:before,
#qr--popout > .qr--body > .qr--buttons > .qr--buttons.qr--color .qr--button:before {
  content: '';
  background-color: var(--qr--color);
  position: absolute;
  inset: -5px;
  z-index: -1;
}
#qr--bar > .qr--buttons > .qr--buttons.qr--color.qr--borderColor .qr--button:before,
#qr--popout > .qr--body > .qr--buttons > .qr--buttons.qr--color.qr--borderColor .qr--button:before {
  display: none;
}
#qr--bar > .qr--buttons > .qr--buttons.qr--color.qr--borderColor:before,
#qr--popout > .qr--body > .qr--buttons > .qr--buttons.qr--color.qr--borderColor:before,
#qr--bar > .qr--buttons > .qr--buttons.qr--color.qr--borderColor:after,
#qr--popout > .qr--body > .qr--buttons > .qr--buttons.qr--color.qr--borderColor:after {
  content: '';
  width: 5px;
  background-color: var(--qr--color);
}
#qr--bar > .qr--buttons .qr--button,
#qr--popout > .qr--body > .qr--buttons .qr--button {
  color: var(--SmartThemeBodyColor);
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: 10px;
  padding: 3px 5px;
  margin: 3px 0;
  cursor: pointer;
  transition: 0.3s;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  position: relative;
}
#qr--bar > .qr--buttons .qr--button:hover,
#qr--popout > .qr--body > .qr--buttons .qr--button:hover {
  background-color: #4d4d4d;
}
#qr--bar > .qr--buttons .qr--button .qr--hidden,
#qr--popout > .qr--body > .qr--buttons .qr--button .qr--hidden {
  display: none;
}
#qr--bar > .qr--buttons .qr--button .qr--button-icon,
#qr--popout > .qr--body > .qr--buttons .qr--button .qr--button-icon {
  margin: 0 0.5em;
}
#qr--bar > .qr--buttons .qr--button > .qr--button-expander,
#qr--popout > .qr--body > .qr--buttons .qr--button > .qr--button-expander {
  display: none;
}
#qr--bar > .qr--buttons .qr--button.qr--hasCtx > .qr--button-expander,
#qr--popout > .qr--body > .qr--buttons .qr--button.qr--hasCtx > .qr--button-expander {
  display: block;
}
.qr--button-expander {
  border-left: 1px solid;
  margin-left: 1em;
  text-align: center;
  width: 2em;
}
.qr--button-expander:hover {
  font-weight: bold;
}
.ctx-blocker {
  /* backdrop-filter: blur(1px); */
  /* background-color: rgba(0 0 0 / 10%); */
  bottom: 0;
  left: 0;
  position: fixed;
  right: 0;
  top: 0;
  z-index: 999;
}
.ctx-menu {
  position: absolute;
  overflow: visible;
}
.list-group .list-group-item.ctx-header {
  font-weight: bold;
  cursor: default;
}
.ctx-item + .ctx-header {
  border-top: 1px solid;
}
.ctx-item {
  position: relative;
}
.ctx-expander {
  border-left: 1px solid;
  margin-left: 1em;
  text-align: center;
  width: 2em;
}
.ctx-expander:hover {
  font-weight: bold;
}
.ctx-sub-menu {
  position: absolute;
  top: 0;
  left: 100%;
}
@media screen and (max-width: 1000px) {
  .ctx-blocker {
    position: absolute;
  }
  .list-group .list-group-item.ctx-item {
    padding: 1em;
  }
}
#qr--settings .qr--head {
  display: flex;
  align-items: baseline;
  gap: 1em;
}
#qr--settings .qr--head > .qr--title {
  font-weight: bold;
}
#qr--settings .qr--head > .qr--actions {
  display: flex;
  flex-direction: row;
  align-items: baseline;
  gap: 0.5em;
}
#qr--settings .qr--setList > .qr--item {
  display: flex;
  flex-direction: row;
  gap: 0.5em;
  align-items: baseline;
  padding: 0 0.5em;
}
#qr--settings .qr--setList > .qr--item > .drag-handle {
  padding: 0.75em;
}
#qr--settings .qr--setList > .qr--item > .qr--visible {
  flex: 0 0 auto;
  display: flex;
  flex-direction: row;
}
#qr--settings #qr--set-settings #qr--injectInputContainer {
  flex-wrap: nowrap;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents {
  padding: 0 0.5em;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--set-itemAdder {
  display: flex;
  align-items: center;
  opacity: 0;
  transition: 100ms;
  margin: -2px 0 -11px 0;
  position: relative;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--set-itemAdder .qr--actions {
  display: flex;
  gap: 0.25em;
  flex: 0 0 auto;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--set-itemAdder .qr--actions .qr--action {
  margin: 0;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--set-itemAdder:before,
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--set-itemAdder:after {
  content: "";
  display: block;
  flex: 1 1 auto;
  border: 1px solid;
  margin: 0 1em;
  height: 0;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--set-itemAdder:hover,
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--set-itemAdder:focus-within {
  opacity: 1;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--content {
  display: flex;
  flex-direction: row;
  gap: 0.5em;
  align-items: baseline;
  padding: 0.25em 0;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--content > :nth-child(2) {
  flex: 0 0 auto;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--content > :nth-child(2) {
  flex: 1 1 25%;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--content > :nth-child(3) {
  flex: 0 0 auto;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--content > :nth-child(4) {
  flex: 1 1 75%;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--content > :nth-child(5) {
  flex: 0 1 auto;
  display: flex;
  gap: 0.25em;
  justify-content: flex-end;
  flex-wrap: wrap;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--content > .drag-handle {
  padding: 0.75em;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--content .qr--set-itemLabelContainer {
  display: flex;
  align-items: center;
  gap: 0.5em;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--content .qr--set-itemLabelContainer .qr--set-itemIcon:not(.fa-solid) {
  display: none;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--content .qr--set-itemLabelContainer .qr--set-itemLabel {
  min-width: 24px;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--content .qr--set-itemLabel,
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--content .qr--action {
  margin: 0;
}
#qr--settings #qr--set-qrList .qr--set-qrListContents > .qr--set-item .qr--content .qr--set-itemMessage {
  font-size: smaller;
}
#qr--settings .qr--set-qrListActions {
  display: flex;
  flex-direction: row;
  gap: 0.5em;
  justify-content: center;
  padding-bottom: 0.5em;
}
#qr--qrOptions {
  display: flex;
  flex-direction: column;
  padding-right: 1px;
}
#qr--qrOptions > #qr--ctxEditor .qr--ctxItem {
  display: flex;
  flex-direction: row;
  gap: 0.5em;
  align-items: baseline;
}
#qr--qrOptions > #qr--autoExec .checkbox_label {
  text-wrap: nowrap;
}
#qr--qrOptions > #qr--autoExec .checkbox_label .fa-fw {
  margin-right: 2px;
}
@media screen and (max-width: 750px) {
  body .popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor {
    flex-direction: column;
    overflow: auto;
  }
  body .popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main {
    flex: 0 0 auto;
  }
  body .popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels {
    flex-direction: column;
  }
  body .popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder {
    min-height: 50dvh;
    height: 50dvh;
  }
}
.popup:has(#qr--modalEditor) {
  aspect-ratio: unset;
  width: unset;
}
.popup:has(#qr--modalEditor):has(.qr--isExecuting.qr--minimized) {
  min-width: unset;
  min-height: unset;
  height: auto !important;
  width: min-content !important;
  position: absolute;
  right: 1em;
  top: 1em;
  left: unset;
  bottom: unset;
  margin: unset;
  padding: 0;
}
.popup:has(#qr--modalEditor):has(.qr--isExecuting.qr--minimized)::backdrop {
  backdrop-filter: unset;
  background-color: transparent;
}
.popup:has(#qr--modalEditor):has(.qr--isExecuting.qr--minimized) .popup-body {
  flex: 0 0 auto;
  height: min-content;
  width: min-content;
}
.popup:has(#qr--modalEditor):has(.qr--isExecuting.qr--minimized) .popup-content {
  flex: 0 0 auto;
  margin-top: 0;
}
.popup:has(#qr--modalEditor):has(.qr--isExecuting.qr--minimized) .popup-content > #qr--modalEditor {
  max-height: 50vh;
}
.popup:has(#qr--modalEditor):has(.qr--isExecuting.qr--minimized) .popup-content > #qr--modalEditor > #qr--main,
.popup:has(#qr--modalEditor):has(.qr--isExecuting.qr--minimized) .popup-content > #qr--modalEditor > #qr--resizeHandle,
.popup:has(#qr--modalEditor):has(.qr--isExecuting.qr--minimized) .popup-content > #qr--modalEditor > #qr--qrOptions > h3,
.popup:has(#qr--modalEditor):has(.qr--isExecuting.qr--minimized) .popup-content > #qr--modalEditor > #qr--qrOptions > #qr--modal-executeButtons,
.popup:has(#qr--modalEditor):has(.qr--isExecuting.qr--minimized) .popup-content > #qr--modalEditor > #qr--qrOptions > #qr--modal-executeProgress {
  display: none;
}
.popup:has(#qr--modalEditor):has(.qr--isExecuting.qr--minimized) .popup-content > #qr--modalEditor #qr--qrOptions {
  width: auto;
}
.popup:has(#qr--modalEditor):has(.qr--isExecuting.qr--minimized) .popup-content > #qr--modalEditor #qr--modal-debugButtons .qr--modal-debugButton#qr--modal-maximize {
  display: flex;
}
.popup:has(#qr--modalEditor):has(.qr--isExecuting.qr--minimized) .popup-content > #qr--modalEditor #qr--modal-debugButtons .qr--modal-debugButton#qr--modal-minimize {
  display: none;
}
.popup:has(#qr--modalEditor):has(.qr--isExecuting.qr--minimized) .popup-content > #qr--modalEditor #qr--modal-debugState {
  padding-top: 0;
}
.popup:has(#qr--modalEditor):has(.qr--isExecuting) .popup-controls {
  display: none;
}
.popup:has(#qr--modalEditor):has(.qr--isExecuting) .qr--highlight {
  position: absolute;
  z-index: 50000;
  pointer-events: none;
  background-color: rgba(47, 150, 180, 0.5);
}
.popup:has(#qr--modalEditor):has(.qr--isExecuting) .qr--highlight.qr--unresolved {
  background-color: rgba(255, 255, 0, 0.5);
}
.popup:has(#qr--modalEditor):has(.qr--isExecuting) .qr--highlight-secondary {
  position: absolute;
  z-index: 50000;
  pointer-events: none;
  border: 3px solid red;
}
.popup:has(#qr--modalEditor) .popup-content {
  display: flex;
  flex-direction: column;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor {
  flex: 1 1 auto;
  display: flex;
  flex-direction: row;
  gap: 1em;
  overflow: hidden;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting #qr--main > h3:first-child,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting #qr--main > .qr--labels,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting #qr--main > .qr--modal-messageContainer > .qr--modal-editorSettings,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting #qr--qrOptions > h3:first-child,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting #qr--qrOptions > #qr--ctxEditor,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting #qr--qrOptions > .qr--ctxEditorActions,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting #qr--qrOptions > .qr--ctxEditorActions + h3,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting #qr--qrOptions > .qr--ctxEditorActions + h3 + div {
  display: none;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder > #qr--modal-message {
  visibility: hidden;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting #qr--modal-debugButtons {
  display: flex;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting #qr--modal-debugButtons .menu_button:not(#qr--modal-minimize, #qr--modal-maximize) {
  cursor: not-allowed;
  opacity: 0.5;
  pointer-events: none;
  transition: 200ms;
  border-color: transparent;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting.qr--isPaused #qr--modal-debugButtons .menu_button:not(#qr--modal-minimize, #qr--modal-maximize) {
  cursor: pointer;
  opacity: 1;
  pointer-events: all;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting.qr--isPaused #qr--modal-debugButtons .menu_button:not(#qr--modal-minimize, #qr--modal-maximize)#qr--modal-resume {
  animation-name: qr--debugPulse;
  animation-duration: 1500ms;
  animation-timing-function: ease-in-out;
  animation-delay: 0s;
  animation-iteration-count: infinite;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting.qr--isPaused #qr--modal-debugButtons .menu_button:not(#qr--modal-minimize, #qr--modal-maximize)#qr--modal-resume {
  border-color: #51a351;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting.qr--isPaused #qr--modal-debugButtons .menu_button:not(#qr--modal-minimize, #qr--modal-maximize)#qr--modal-step {
  border-color: var(--SmartThemeQuoteColor);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting.qr--isPaused #qr--modal-debugButtons .menu_button:not(#qr--modal-minimize, #qr--modal-maximize)#qr--modal-stepInto {
  border-color: var(--SmartThemeQuoteColor);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting.qr--isPaused #qr--modal-debugButtons .menu_button:not(#qr--modal-minimize, #qr--modal-maximize)#qr--modal-stepOut {
  border-color: var(--SmartThemeQuoteColor);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting #qr--resizeHandle {
  width: 6px;
  background-color: var(--SmartThemeBorderColor);
  border: 2px solid var(--SmartThemeBlurTintColor);
  transition: border-color 200ms, background-color 200ms;
  cursor: w-resize;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting #qr--resizeHandle:hover {
  background-color: var(--SmartThemeQuoteColor);
  border-color: var(--SmartThemeQuoteColor);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor.qr--isExecuting #qr--qrOptions {
  width: var(--width, auto);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main {
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels {
  flex: 0 0 auto;
  display: flex;
  flex-direction: row;
  gap: 0.5em;
  padding: 1px;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label {
  flex: 1 1 1px;
  display: flex;
  flex-direction: column;
  position: relative;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label.qr--fit,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label.qr--fit {
  flex: 0 0 auto;
  justify-content: center;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label .qr--inputGroup,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label .qr--inputGroup {
  display: flex;
  align-items: baseline;
  gap: 0.5em;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label .qr--inputGroup input,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label .qr--inputGroup input {
  flex: 1 1 auto;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label .qr--labelText,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label .qr--labelText {
  flex: 1 1 auto;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label .qr--labelHint,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label .qr--labelHint {
  flex: 1 1 auto;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label input,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label input {
  flex: 0 0 auto;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label .qr--modal-switcherList,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label .qr--modal-switcherList {
  background-color: var(--stcdx--bgColor);
  border: 1px solid var(--SmartThemeBorderColor);
  backdrop-filter: blur(var(--SmartThemeBlurStrength));
  border-radius: 10px;
  font-size: smaller;
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  overflow: auto;
  margin: 0;
  padding: 0.5em;
  max-height: 50vh;
  list-style: none;
  z-index: 40000;
  max-width: 100%;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label .qr--modal-switcherList .qr--modal-switcherItem,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label .qr--modal-switcherList .qr--modal-switcherItem {
  display: flex;
  gap: 1em;
  text-align: left;
  opacity: 0.75;
  transition: 200ms;
  cursor: pointer;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label .qr--modal-switcherList .qr--modal-switcherItem:hover,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label .qr--modal-switcherList .qr--modal-switcherItem:hover {
  opacity: 1;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label .qr--modal-switcherList .qr--modal-switcherItem.qr--current,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label .qr--modal-switcherList .qr--modal-switcherItem.qr--current {
  opacity: 1;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label .qr--modal-switcherList .qr--modal-switcherItem.qr--current .qr--label,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label .qr--modal-switcherList .qr--modal-switcherItem.qr--current .qr--label,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label .qr--modal-switcherList .qr--modal-switcherItem.qr--current .qr--id,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label .qr--modal-switcherList .qr--modal-switcherItem.qr--current .qr--id {
  font-weight: bold;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label .qr--modal-switcherList .qr--label,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label .qr--modal-switcherList .qr--label {
  white-space: nowrap;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label .qr--modal-switcherList .qr--label .menu_button,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label .qr--modal-switcherList .qr--label .menu_button {
  display: inline-block;
  height: min-content;
  width: min-content;
  margin: 0 0.5em 0 0;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label .qr--modal-switcherList .qr--id,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label .qr--modal-switcherList .qr--id {
  opacity: 0.5;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label .qr--modal-switcherList .qr--id:before,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label .qr--modal-switcherList .qr--id:before {
  content: "[";
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label .qr--modal-switcherList .qr--id:after,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label .qr--modal-switcherList .qr--id:after {
  content: "]";
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > label .qr--modal-switcherList .qr--message,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--labels > .label .qr--modal-switcherList .qr--message {
  height: 1lh;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  opacity: 0.5;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer {
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > .qr--modal-editorSettings {
  display: flex;
  flex-wrap: wrap;
  flex-direction: row;
  column-gap: 1em;
  color: var(--grey70);
  font-size: smaller;
  align-items: baseline;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > .qr--modal-editorSettings > .checkbox_label {
  white-space: nowrap;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > .qr--modal-editorSettings > .checkbox_label > input {
  font-size: inherit;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder {
  flex: 1 1 auto;
  display: grid;
  text-align: left;
  overflow: hidden;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder.qr--noSyntax > #qr--modal-messageSyntax {
  display: none;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder.qr--noSyntax > #qr--modal-message {
  background-color: var(--ac-style-color-background);
  color: var(--ac-style-color-text);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder.qr--noSyntax > #qr--modal-message::-webkit-scrollbar,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder.qr--noSyntax > #qr--modal-message::-webkit-scrollbar-thumb {
  visibility: visible;
  cursor: unset;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder.qr--noSyntax > #qr--modal-message::selection {
  color: unset;
  background-color: rgba(108 171 251 / 0.25);
}
@supports (color: rgb(from white r g b / 0.25)) {
  .popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder.qr--noSyntax > #qr--modal-message::selection {
    background-color: rgb(from var(--ac-style-color-matchedText) r g b / 0.25);
  }
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder > #qr--modal-messageSyntax {
  grid-column: 1;
  grid-row: 1;
  padding: 0;
  margin: 0;
  border: none;
  overflow: hidden;
  min-width: 100%;
  width: 0;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder > #qr--modal-messageSyntax > #qr--modal-messageSyntaxInner {
  height: 100%;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder > #qr--modal-message {
  background-color: transparent;
  color: transparent;
  grid-column: 1;
  grid-row: 1;
  caret-color: var(--ac-style-color-text);
  overflow: auto;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder > #qr--modal-message::-webkit-scrollbar,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder > #qr--modal-message::-webkit-scrollbar-thumb {
  visibility: hidden;
  cursor: default;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder > #qr--modal-message::selection {
  color: transparent;
  background-color: rgba(108 171 251 / 0.25);
}
@supports (color: rgb(from white r g b / 0.25)) {
  .popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder > #qr--modal-message::selection {
    background-color: rgb(from var(--ac-style-color-matchedText) r g b / 0.25);
  }
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder #qr--modal-message,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor > #qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder #qr--modal-messageSyntaxInner {
  font-family: var(--monoFontFamily);
  padding: 0.75em;
  margin: 0;
  resize: none;
  line-height: 1.2;
  border: 1px solid var(--SmartThemeBorderColor);
  border-radius: 5px;
  position: relative;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-icon {
  height: 100%;
  aspect-ratio: 1 / 1;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeButtons {
  display: flex;
  gap: 1em;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeButtons .qr--modal-executeButton {
  border-width: 2px;
  border-style: solid;
  display: flex;
  flex-direction: row;
  gap: 0.5em;
  padding: 0.5em 0.75em;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeButtons .qr--modal-executeButton .qr--modal-executeComboIcon {
  display: flex;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeButtons #qr--modal-execute {
  transition: 200ms;
  filter: grayscale(0);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeButtons #qr--modal-execute.qr--busy {
  cursor: wait;
  opacity: 0.5;
  filter: grayscale(1);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeButtons #qr--modal-execute {
  border-color: #51a351;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeButtons #qr--modal-pause,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeButtons #qr--modal-stop {
  cursor: default;
  opacity: 0.5;
  filter: grayscale(1);
  pointer-events: none;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeButtons .qr--busy ~ #qr--modal-pause,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeButtons .qr--busy ~ #qr--modal-stop {
  cursor: pointer;
  opacity: 1;
  filter: grayscale(0);
  pointer-events: all;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeButtons #qr--modal-pause {
  border-color: #92befc;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeButtons #qr--modal-stop {
  border-color: #d78872;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugButtons {
  display: none;
  gap: 1em;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugButtons .qr--modal-debugButton {
  aspect-ratio: 1.25 / 1;
  width: 2.25em;
  position: relative;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugButtons .qr--modal-debugButton:not(.fa-solid) {
  border-width: 1px;
  border-style: solid;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugButtons .qr--modal-debugButton:not(.fa-solid):after {
  content: '';
  position: absolute;
  inset: 3px;
  background-color: var(--SmartThemeBodyColor);
  mask-size: contain;
  mask-position: center;
  mask-repeat: no-repeat;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugButtons .qr--modal-debugButton#qr--modal-resume:after {
  mask-image: url('/img/step-resume.svg');
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugButtons .qr--modal-debugButton#qr--modal-step:after {
  mask-image: url('/img/step-over.svg');
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugButtons .qr--modal-debugButton#qr--modal-stepInto:after {
  mask-image: url('/img/step-into.svg');
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugButtons .qr--modal-debugButton#qr--modal-stepOut:after {
  mask-image: url('/img/step-out.svg');
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugButtons .qr--modal-debugButton#qr--modal-maximize {
  display: none;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-send_textarea {
  flex: 0 0 auto;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeProgress {
  --prog: 0;
  --progColor: #92befc;
  --progFlashColor: #d78872;
  --progSuccessColor: #51a351;
  --progErrorColor: #bd362f;
  --progAbortedColor: #d78872;
  flex: 0 0 auto;
  height: 0.5em;
  background-color: var(--black50a);
  position: relative;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeProgress:after {
  content: '';
  background-color: var(--progColor);
  position: absolute;
  inset: 0;
  right: calc(100% - var(--prog) * 1%);
  transition: 200ms;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeProgress.qr--paused:after {
  animation-name: qr--progressPulse;
  animation-duration: 1500ms;
  animation-timing-function: ease-in-out;
  animation-delay: 0s;
  animation-iteration-count: infinite;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeProgress.qr--aborted:after {
  background-color: var(--progAbortedColor);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeProgress.qr--success:after {
  background-color: var(--progSuccessColor);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeProgress.qr--error:after {
  background-color: var(--progErrorColor);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeErrors {
  display: none;
  text-align: left;
  font-size: smaller;
  background-color: #bd362f;
  color: white;
  padding: 0.5em;
  overflow: auto;
  min-width: 100%;
  width: 0;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeErrors.qr--hasErrors {
  display: block;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeResult {
  display: none;
  text-align: left;
  font-size: smaller;
  background-color: #51a351;
  color: white;
  padding: 0.5em;
  overflow: auto;
  min-width: 100%;
  width: 0;
  white-space: pre-wrap;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeResult.qr--hasResult {
  display: block;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-executeResult:before {
  content: 'Result: ';
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState {
  display: none;
  text-align: left;
  font-size: smaller;
  font-family: var(--monoFontFamily);
  color: white;
  padding: 0.5em 0;
  overflow: auto;
  min-width: 100%;
  width: 0;
  white-space: pre-wrap;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState.qr--active {
  display: block;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope {
  display: grid;
  grid-template-columns: 0fr 1fr 1fr;
  column-gap: 0em;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--title {
  grid-column: 1 / 4;
  font-weight: bold;
  font-family: var(--mainFontFamily);
  background-color: var(--black50a);
  padding: 0.25em;
  margin-top: 0.5em;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--var,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--macro,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--pipe {
  display: contents;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--var:nth-child(2n + 1) .qr--key,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--macro:nth-child(2n + 1) .qr--key,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--pipe:nth-child(2n + 1) .qr--key,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--var:nth-child(2n + 1) .qr--val,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--macro:nth-child(2n + 1) .qr--val,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--pipe:nth-child(2n + 1) .qr--val {
  background-color: rgb(from var(--SmartThemeEmColor) r g b / 0.25);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--var:nth-child(2n + 1) .qr--val:nth-child(2n),
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--macro:nth-child(2n + 1) .qr--val:nth-child(2n),
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--pipe:nth-child(2n + 1) .qr--val:nth-child(2n) {
  background-color: rgb(from var(--SmartThemeEmColor) r g b / 0.125);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--var:nth-child(2n + 1) .qr--val:hover,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--macro:nth-child(2n + 1) .qr--val:hover,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--pipe:nth-child(2n + 1) .qr--val:hover {
  background-color: rgb(from var(--SmartThemeEmColor) r g b / 0.5);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--var:nth-child(2n) .qr--val:nth-child(2n),
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--macro:nth-child(2n) .qr--val:nth-child(2n),
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--pipe:nth-child(2n) .qr--val:nth-child(2n) {
  background-color: rgb(from var(--SmartThemeEmColor) r g b / 0.0625);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--var:nth-child(2n) .qr--val:hover,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--macro:nth-child(2n) .qr--val:hover,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--pipe:nth-child(2n) .qr--val:hover {
  background-color: rgb(from var(--SmartThemeEmColor) r g b / 0.5);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--var.qr--isHidden .qr--key,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--macro.qr--isHidden .qr--key,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--pipe.qr--isHidden .qr--key,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--var.qr--isHidden .qr--val,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--macro.qr--isHidden .qr--val,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--pipe.qr--isHidden .qr--val {
  opacity: 0.5;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--var .qr--val,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--macro .qr--val,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--pipe .qr--val {
  grid-column: 2 / 4;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--var .qr--val.qr--singleCol,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--macro .qr--val.qr--singleCol,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--pipe .qr--val.qr--singleCol {
  grid-column: unset;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--var .qr--val.qr--simple:before,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--macro .qr--val.qr--simple:before,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--pipe .qr--val.qr--simple:before,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--var .qr--val.qr--simple:after,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--macro .qr--val.qr--simple:after,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--pipe .qr--val.qr--simple:after {
  content: '"';
  color: var(--SmartThemeQuoteColor);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--var .qr--val.qr--unresolved:after,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--macro .qr--val.qr--unresolved:after,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--pipe .qr--val.qr--unresolved:after {
  content: '-UNRESOLVED-';
  font-style: italic;
  color: var(--SmartThemeQuoteColor);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--key {
  margin-left: 0.5em;
  padding-right: 1em;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--key:after {
  content: ": ";
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--pipe > .qr--key:before,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--macro > .qr--key:before {
  content: "{{";
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--pipe > .qr--key:after,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--macro > .qr--key:after {
  content: "}}: ";
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--scope {
  display: contents;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--scope .qr--pipe .qr--key,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--scope .qr--scope .qr--pipe .qr--val {
  opacity: 0.5;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--stack {
  display: grid;
  grid-template-columns: 1fr 0fr;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--stack .qr--title {
  grid-column: 1 / 3;
  font-weight: bold;
  font-family: var(--mainFontFamily);
  background-color: var(--black50a);
  padding: 0.25em;
  margin-top: 1em;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--stack .qr--item {
  display: contents;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--stack .qr--item:nth-child(2n + 1) .qr--name,
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--stack .qr--item:nth-child(2n + 1) .qr--source {
  background-color: rgb(from var(--SmartThemeEmColor) r g b / 0.25);
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--stack .qr--item .qr--name {
  margin-left: 0.5em;
}
.popup:has(#qr--modalEditor) .popup-content > #qr--modalEditor #qr--modal-debugState .qr--stack .qr--item .qr--source {
  opacity: 0.5;
  text-align: right;
  white-space: nowrap;
}
@keyframes qr--progressPulse {
  0%,
  100% {
    background-color: var(--progColor);
  }
  50% {
    background-color: var(--progFlashColor);
  }
}
@keyframes qr--debugPulse {
  0%,
  100% {
    border-color: #51a351;
  }
  50% {
    border-color: #92befc;
  }
}
.popup.qr--hide {
  opacity: 0 !important;
}
.popup.qr--hide::backdrop {
  opacity: 0 !important;
}
.popup.qr--hide::backdrop {
  opacity: 0 !important;
}
.popup:has(.qr--transferModal) .popup-button-ok {
  display: flex;
  align-items: center;
  flex-direction: column;
  white-space: pre;
  font-weight: normal;
  box-shadow: 0 0 0;
  transition: 200ms;
}
.popup:has(.qr--transferModal) .popup-button-ok:after {
  content: 'Transfer';
  height: 0;
  overflow: hidden;
  font-weight: bold;
}
.popup:has(.qr--transferModal) .qr--copy {
  display: flex;
  align-items: center;
  flex-direction: column;
  white-space: pre;
  font-weight: normal;
  box-shadow: 0 0 0;
  transition: 200ms;
}
.popup:has(.qr--transferModal) .qr--copy:after {
  content: 'Copy';
  height: 0;
  overflow: hidden;
  font-weight: bold;
}
.popup:has(.qr--transferModal):has(.qr--transferSelect:focus) .popup-button-ok {
  font-weight: bold;
  box-shadow: 0 0 10px;
}
.popup:has(.qr--transferModal):has(.qr--transferSelect:focus).qr--isCopy .popup-button-ok {
  font-weight: normal;
  box-shadow: 0 0 0;
}
.popup:has(.qr--transferModal):has(.qr--transferSelect:focus).qr--isCopy .qr--copy {
  font-weight: bold;
  box-shadow: 0 0 10px;
}



---
File: /style.less
---

@keyframes qr--success {
    0%, 100% {
        color: var(--SmartThemeBodyColor);
    }
    25%, 75% {
        color: rgb(81, 163, 81);
    }
}
&.qr--success {
    animation-name: qr--success;
    animation-duration: 3s;
    animation-timing-function: linear;
    animation-delay: 0s;
    animation-iteration-count: 1;
}
#qr--bar {
    outline: none;
    margin: 0;
    transition: 0.3s;
    opacity: 0.7;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    max-width: 100%;
    overflow-x: auto;
    order: 1;
    position: relative;

    >#qr--popoutTrigger {
        position: absolute;
        right: 0.25em;
        top: 0;
    }
}
#qr--bar.popoutVisible {
    padding-right: 2.5em;
}

#qr--popout {
    display: flex;
    flex-direction: column;
    padding: 0;
    z-index: 31;

    >.qr--header {
        flex: 0 0 auto;
        height: 2em;
        position: relative;

        >.qr--controls {
            >.qr--close {
                height: 15px;
                aspect-ratio: 1 / 1;
                font-size: 20px;
                opacity: 0.5;
                transition: all 250ms;
            }
        }
    }

    >.qr--body {
        overflow-y: auto;
    }
}

#qr--bar,
#qr--popout>.qr--body {
    >.qr--buttons {
        --qr--color: transparent;
        &.qr--color {
            background-color: var(--qr--color);
        }
        &.qr--borderColor {
            background-color: transparent;
            border-left: 5px solid var(--qr--color);
            border-right: 5px solid var(--qr--color);
        }
        &:has(.qr--buttons.qr--color) {
            margin: 5px;
        }
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 5px;
        width: 100%;

        >.qr--buttons {
            display: contents;
            &.qr--color {
                .qr--button:before {
                    content: '';
                    background-color: var(--qr--color);
                    position: absolute;
                    inset: -5px;
                    z-index: -1;
                }
                &.qr--borderColor {
                    .qr--button:before {
                        display: none;
                    }
                    &:before, &:after {
                        content: '';
                        width: 5px;
                        background-color: var(--qr--color);
                    }
                }
            }
        }

        .qr--button {
            color: var(--SmartThemeBodyColor);
            // background-color: var(--black50a);
            border: 1px solid var(--SmartThemeBorderColor);
            border-radius: 10px;
            padding: 3px 5px;
            margin: 3px 0;
            cursor: pointer;
            transition: 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            position: relative;

            &:hover {
                background-color: rgb(30% 30% 30%);
            }

            .qr--hidden {
                display: none;
            }
            .qr--button-icon {
                margin: 0 0.5em;
            }

            >.qr--button-expander {
                display: none;
            }

            &.qr--hasCtx {
                >.qr--button-expander {
                    display: block;
                }
            }
        }
    }
}

.qr--button-expander {
    border-left: 1px solid;
    margin-left: 1em;
    text-align: center;
    width: 2em;

    &:hover {
        font-weight: bold;
    }
}

.ctx-blocker {
    /* backdrop-filter: blur(1px); */
    /* background-color: rgba(0 0 0 / 10%); */
    bottom: 0;
    left: 0;
    position: fixed;
    right: 0;
    top: 0;
    z-index: 999;
}

.ctx-menu {
    position: absolute;
    overflow: visible;
}

.list-group .list-group-item.ctx-header {
    font-weight: bold;
    cursor: default;
}

.ctx-item+.ctx-header {
    border-top: 1px solid;
}

.ctx-item {
    position: relative;
}

.ctx-expander {
    border-left: 1px solid;
    margin-left: 1em;
    text-align: center;
    width: 2em;
}

.ctx-expander:hover {
    font-weight: bold;
}

.ctx-sub-menu {
    position: absolute;
    top: 0;
    left: 100%;
}

@media screen and (max-width: 1000px) {
    .ctx-blocker {
        position: absolute;
    }

    .list-group .list-group-item.ctx-item {
        padding: 1em;
    }
}



#qr--settings {
    .qr--head {
        display: flex;
        align-items: baseline;
        gap: 1em;

        >.qr--title {
            font-weight: bold;
        }

        >.qr--actions {
            display: flex;
            flex-direction: row;
            align-items: baseline;
            gap: 0.5em;
        }
    }

    .qr--setList {
        >.qr--item {
            display: flex;
            flex-direction: row;
            gap: 0.5em;
            align-items: baseline;
            padding: 0 0.5em;

            >.drag-handle {
                padding: 0.75em;
            }

            >.qr--visible {
                flex: 0 0 auto;
                display: flex;
                flex-direction: row;
            }
        }
    }

    #qr--set-settings {
        #qr--injectInputContainer {
            flex-wrap: nowrap;
        }
    }

    #qr--set-qrList {
        .qr--set-qrListContents> {
            padding: 0 0.5em;

            >.qr--set-item .qr--set-itemAdder {
                display: flex;
                align-items: center;
                opacity: 0;
                transition: 100ms;
                margin: -2px 0 -11px 0;
                position: relative;
                .qr--actions {
                    display: flex;
                    gap: 0.25em;
                    flex: 0 0 auto;
                    .qr--action {
                        margin: 0;
                    }
                }
                &:before, &:after {
                    content: "";
                    display: block;
                    flex: 1 1 auto;
                    border: 1px solid;
                    margin: 0 1em;
                    height: 0;
                }
                &:hover, &:focus-within {
                    opacity: 1;
                }
            }
            >.qr--set-item .qr--content {
                display: flex;
                flex-direction: row;
                gap: 0.5em;
                align-items: baseline;
                padding: 0.25em 0;

                > :nth-child(2) {
                    flex: 0 0 auto;
                }

                > :nth-child(2) {
                    flex: 1 1 25%;
                }

                > :nth-child(3) {
                    flex: 0 0 auto;
                }

                > :nth-child(4) {
                    flex: 1 1 75%;
                }

                > :nth-child(5) {
                    flex: 0 1 auto;
                    display: flex;
                    gap: 0.25em;
                    justify-content: flex-end;
                    flex-wrap: wrap;
                }

                >.drag-handle {
                    padding: 0.75em;
                }

                .qr--set-itemLabelContainer {
                    display: flex;
                    align-items: center;
                    gap: 0.5em;
                    .qr--set-itemIcon:not(.fa-solid) {
                        display: none;
                    }
                    .qr--set-itemLabel {
                        min-width: 24px;
                    }
                }

                .qr--set-itemLabel,
                .qr--action {
                    margin: 0;
                }

                .qr--set-itemMessage {
                    font-size: smaller;
                }
            }


        }
    }

    .qr--set-qrListActions {
        display: flex;
        flex-direction: row;
        gap: 0.5em;
        justify-content: center;
        padding-bottom: 0.5em;
    }
}





#qr--qrOptions {
    display: flex;
    flex-direction: column;
    padding-right: 1px;

    >#qr--ctxEditor {
        .qr--ctxItem {
            display: flex;
            flex-direction: row;
            gap: 0.5em;
            align-items: baseline;
        }
    }
        >#qr--autoExec {
            .checkbox_label {
                text-wrap: nowrap;

                .fa-fw {
                    margin-right: 2px;
                }
            }
        }
}



@media screen and (max-width: 750px) {
    body .popup:has(#qr--modalEditor) .popup-content>#qr--modalEditor {
        flex-direction: column;
        overflow: auto;

        >#qr--main {
            flex: 0 0 auto;
        }

        >#qr--main>.qr--labels {
            flex-direction: column;
        }

        >#qr--main>.qr--modal-messageContainer>#qr--modal-messageHolder {
            min-height: 50dvh;
            height: 50dvh;
        }
    }
}

.popup:has(#qr--modalEditor) {
    aspect-ratio: unset;
    width: unset;

    &:has(.qr--isExecuting.qr--minimized) {
        min-width: unset;
        min-height: unset;
        height: auto !important;
        width: min-content !important;
        position: absolute;
        right: 1em;
        top: 1em;
        left: unset;
        bottom: unset;
        margin: unset;
        padding: 0;
        &::backdrop {
            backdrop-filter: unset;
            background-color: transparent;
        }
        .popup-body {
            flex: 0 0 auto;
            height: min-content;
            width: min-content;
        }
        .popup-content {
            flex: 0 0 auto;
            margin-top: 0;

            > #qr--modalEditor {
                max-height: 50vh;
                > #qr--main,
                > #qr--resizeHandle,
                > #qr--qrOptions > h3,
                > #qr--qrOptions > #qr--modal-executeButtons,
                > #qr--qrOptions > #qr--modal-executeProgress
                {
                    display: none;
                }
                #qr--qrOptions {
                    width: auto;
                }
                #qr--modal-debugButtons .qr--modal-debugButton#qr--modal-maximize {
                    display: flex;
                }
                #qr--modal-debugButtons .qr--modal-debugButton#qr--modal-minimize {
                    display: none;
                }
                #qr--modal-debugState {
                    padding-top: 0;
                }
            }
        }
    }
	&:has(.qr--isExecuting) {
		.popup-controls {
			display: none;
		}

		.qr--highlight {
			position: absolute;
			z-index: 50000;
			pointer-events: none;
			background-color: rgb(47 150 180 / 0.5);
			&.qr--unresolved {
				background-color: rgb(255 255 0 / 0.5);
			}
		}
		.qr--highlight-secondary {
			position: absolute;
			z-index: 50000;
			pointer-events: none;
			border: 3px solid red;
		}
	}

    .popup-content {
        display: flex;
        flex-direction: column;

        >#qr--modalEditor {
            flex: 1 1 auto;
            display: flex;
            flex-direction: row;
            gap: 1em;
            overflow: hidden;

			&.qr--isExecuting {
				#qr--main > h3:first-child,
				#qr--main > .qr--labels,
				#qr--main > .qr--modal-messageContainer > .qr--modal-editorSettings,
				#qr--qrOptions > h3:first-child,
				#qr--qrOptions > #qr--ctxEditor,
				#qr--qrOptions > .qr--ctxEditorActions,
				#qr--qrOptions > .qr--ctxEditorActions + h3,
				#qr--qrOptions > .qr--ctxEditorActions + h3 + div
				{
					display: none;
				}
				#qr--main > .qr--modal-messageContainer > #qr--modal-messageHolder > #qr--modal-message {
					visibility: hidden;
				}
				#qr--modal-debugButtons {
					display: flex;
                    .menu_button:not(#qr--modal-minimize, #qr--modal-maximize) {
                        cursor: not-allowed;
                        opacity: 0.5;
                        pointer-events: none;
                        transition: 200ms;
                        border-color: transparent;
                    }
				}
                &.qr--isPaused #qr--modal-debugButtons {
                    .menu_button:not(#qr--modal-minimize, #qr--modal-maximize) {
                        cursor: pointer;
                        opacity: 1;
                        pointer-events: all;
                        &#qr--modal-resume {
                            animation-name: qr--debugPulse;
                            animation-duration: 1500ms;
                            animation-timing-function: ease-in-out;
                            animation-delay: 0s;
                            animation-iteration-count: infinite;
                        }
                        &#qr--modal-resume {
                            border-color: rgb(81, 163, 81);
                        }
                        &#qr--modal-step {
                            border-color: var(--SmartThemeQuoteColor);
                        }
                        &#qr--modal-stepInto {
                            border-color: var(--SmartThemeQuoteColor);
                        }
                        &#qr--modal-stepOut {
                            border-color: var(--SmartThemeQuoteColor);
                        }
                    }
                }
				#qr--resizeHandle {
					width: 6px;
					background-color: var(--SmartThemeBorderColor);
					border: 2px solid var(--SmartThemeBlurTintColor);
					transition: border-color 200ms, background-color 200ms;
					cursor: w-resize;
					&:hover {
						background-color: var(--SmartThemeQuoteColor);
						border-color: var(--SmartThemeQuoteColor);
					}
				}
				#qr--qrOptions {
					width: var(--width, auto);
				}
			}

			> #qr--main {
				flex: 1 1 auto;
				display: flex;
				flex-direction: column;
				overflow: hidden;
				> .qr--labels {
					flex: 0 0 auto;
					display: flex;
					flex-direction: row;
					gap: 0.5em;
					padding: 1px;
					> label, > .label {
						flex: 1 1 1px;
						display: flex;
						flex-direction: column;
                        position: relative;
                        &.qr--fit {
                            flex: 0 0 auto;
                            justify-content: center;
                        }
                        .qr--inputGroup {
                            display: flex;
                            align-items: baseline;
                            gap: 0.5em;
                            input {
                                flex: 1 1 auto;
                            }
                        }
						.qr--labelText {
							flex: 1 1 auto;
						}
						.qr--labelHint {
							flex: 1 1 auto;
						}
						input {
							flex: 0 0 auto;
						}
                        .qr--modal-switcherList {
                            background-color: var(--stcdx--bgColor);
                            border: 1px solid var(--SmartThemeBorderColor);
                            backdrop-filter: blur(var(--SmartThemeBlurStrength));
                            border-radius: 10px;
                            font-size: smaller;
                            position: absolute;
                            top: 100%;
                            left: 0;
                            right: 0;
                            overflow: auto;
                            margin: 0;
                            padding: 0.5em;
                            max-height: 50vh;
                            list-style: none;
                            z-index: 40000;
                            max-width: 100%;
                            .qr--modal-switcherItem {
                                display: flex;
                                gap: 1em;
                                text-align: left;
                                opacity: 0.75;
                                transition: 200ms;
                                cursor: pointer;
                                &:hover {
                                    opacity: 1;
                                }
                                &.qr--current {
                                    opacity: 1;
                                    .qr--label, .qr--id {
                                        font-weight: bold;
                                    }
                                }
                            }
                            .qr--label {
                                white-space: nowrap;
                                .menu_button {
                                    display: inline-block;
                                    height: min-content;
                                    width: min-content;
                                    margin: 0 0.5em 0 0;
                                }
                            }
                            .qr--id {
                                opacity: 0.5;
                                &:before { content: "["; }
                                &:after { content: "]"; }
                            }
                            .qr--message {
                                height: 1lh;
                                overflow: hidden;
                                text-overflow: ellipsis;
                                white-space: nowrap;
                                opacity: 0.5;
                            }
                        }
					}
				}
				> .qr--modal-messageContainer {
					flex: 1 1 auto;
					display: flex;
					flex-direction: column;
					overflow: hidden;
					> .qr--modal-editorSettings {
						display: flex;
                        flex-wrap: wrap;
						flex-direction: row;
						column-gap: 1em;
						color: var(--grey70);
						font-size: smaller;
						align-items: baseline;
						> .checkbox_label {
							white-space: nowrap;
							> input {
								font-size: inherit;
							}
						}
					}
					> #qr--modal-messageHolder {
						flex: 1 1 auto;
						display: grid;
						text-align: left;
						overflow: hidden;
						&.qr--noSyntax {
							> #qr--modal-messageSyntax {
								display: none;
							}
							> #qr--modal-message {
								background-color: var(--ac-style-color-background);
								color: var(--ac-style-color-text);
                                &::-webkit-scrollbar, &::-webkit-scrollbar-thumb {
                                    visibility: visible;
                                    cursor: unset;
                                }
								&::selection {
									color: unset;
									background-color: rgba(108 171 251 / 0.25);
									@supports (color: rgb(from white r g b / 0.25)) {
										background-color: rgb(from var(--ac-style-color-matchedText) r g b / 0.25);
									}
								}
							}
						}
						> #qr--modal-messageSyntax {
							grid-column: 1;
							grid-row: 1;
							padding: 0;
							margin: 0;
							border: none;
							overflow: hidden;
							min-width: 100%;
							width: 0;
							> #qr--modal-messageSyntaxInner {
								height: 100%;
							}
						}
						> #qr--modal-message {
							background-color: transparent;
							color: transparent;
							grid-column: 1;
							grid-row: 1;
							caret-color: var(--ac-style-color-text);
							overflow: auto;
							&::-webkit-scrollbar, &::-webkit-scrollbar-thumb {
								visibility: hidden;
								cursor: default;
							}
							&::selection {
								color: transparent;
								background-color: rgba(108 171 251 / 0.25);
								@supports (color: rgb(from white r g b / 0.25)) {
									background-color: rgb(from var(--ac-style-color-matchedText) r g b / 0.25);
								}
							}
						}
						#qr--modal-message, #qr--modal-messageSyntaxInner {
							font-family: var(--monoFontFamily);
							padding: 0.75em;
							margin: 0;
							resize: none;
							line-height: 1.2;
							border: 1px solid var(--SmartThemeBorderColor);
							border-radius: 5px;
							position: relative;
						}
					}
				}
			}
            #qr--modal-icon {
                height: 100%;
                aspect-ratio: 1 / 1;
            }
            #qr--modal-executeButtons {
                display: flex;
                gap: 1em;

                .qr--modal-executeButton {
                    border-width: 2px;
                    border-style: solid;
                    display: flex;
                    flex-direction: row;
                    gap: 0.5em;
                    padding: 0.5em 0.75em;

                    .qr--modal-executeComboIcon {
                        display: flex;
                    }
                }

                #qr--modal-execute {
                    transition: 200ms;
                    filter: grayscale(0);

                    &.qr--busy {
                        cursor: wait;
                        opacity: 0.5;
                        filter: grayscale(1);
                    }
                }

                #qr--modal-execute {
                    border-color: rgb(81, 163, 81);
                }

                #qr--modal-pause,
                #qr--modal-stop {
                    cursor: default;
                    opacity: 0.5;
                    filter: grayscale(1);
                    pointer-events: none;
                }

                .qr--busy {

                    ~#qr--modal-pause,
                    ~#qr--modal-stop {
                        cursor: pointer;
                        opacity: 1;
                        filter: grayscale(0);
                        pointer-events: all;
                    }
                }

                #qr--modal-pause {
                    border-color: rgb(146, 190, 252);
                }

                #qr--modal-stop {
                    border-color: rgb(215, 136, 114);
                }
            }
			#qr--modal-debugButtons {
				display: none;
				gap: 1em;
				.qr--modal-debugButton {
					aspect-ratio: 1.25 / 1;
					width: 2.25em;
                    position: relative;
                    &:not(.fa-solid) {
                        border-width: 1px;
                        border-style: solid;
                        &:after {
                            content: '';
                            position: absolute;
                            inset: 3px;
                            background-color: var(--SmartThemeBodyColor);
                            mask-size: contain;
                            mask-position: center;
                            mask-repeat: no-repeat;
                        }
                    }
                    &#qr--modal-resume:after {
                        mask-image: url('/img/step-resume.svg');
                    }
                    &#qr--modal-step:after {
                        mask-image: url('/img/step-over.svg');
                    }
                    &#qr--modal-stepInto:after {
                        mask-image: url('/img/step-into.svg');
                    }
                    &#qr--modal-stepOut:after {
                        mask-image: url('/img/step-out.svg');
                    }
                    &#qr--modal-maximize {
                        display: none;
                    }
				}
			}

            #qr--modal-send_textarea {
                flex: 0 0 auto;
            }

            #qr--modal-executeProgress {
                --prog: 0;
                --progColor: rgb(146, 190, 252);
                --progFlashColor: rgb(215, 136, 114);
                --progSuccessColor: rgb(81, 163, 81);
                --progErrorColor: rgb(189, 54, 47);
                --progAbortedColor: rgb(215, 136, 114);
                flex: 0 0 auto;
                height: 0.5em;
                background-color: var(--black50a);
                position: relative;

                &:after {
                    content: '';
                    background-color: var(--progColor);
                    position: absolute;
                    inset: 0;
                    right: calc(100% - var(--prog) * 1%);
                    transition: 200ms;
                }

                &.qr--paused:after {
                    animation-name: qr--progressPulse;
                    animation-duration: 1500ms;
                    animation-timing-function: ease-in-out;
                    animation-delay: 0s;
                    animation-iteration-count: infinite;
                }

                &.qr--aborted:after {
                    background-color: var(--progAbortedColor);
                }

                &.qr--success:after {
                    background-color: var(--progSuccessColor);
                }

                &.qr--error:after {
                    background-color: var(--progErrorColor);
                }
            }

            #qr--modal-executeErrors {
                display: none;

                &.qr--hasErrors {
                    display: block;
                }

                text-align: left;
                font-size: smaller;
                background-color: rgb(189, 54, 47);
                color: white;
                padding: 0.5em;
                overflow: auto;
                min-width: 100%;
                width: 0;
            }

            #qr--modal-executeResult {
                display: none;

                &.qr--hasResult {
                    display: block;
                }

                &:before {
                    content: 'Result: ';
                }

                text-align: left;
                font-size: smaller;
                background-color: rgb(81, 163, 81);
                color: white;
                padding: 0.5em;
                overflow: auto;
                min-width: 100%;
                width: 0;
				white-space: pre-wrap;
			}
			#qr--modal-debugState {
				display: none;
				&.qr--active {
					display: block;
				}
				text-align: left;
				font-size: smaller;
				font-family: var(--monoFontFamily);
				// background-color: rgb(146, 190, 252);
				color: white;
				padding: 0.5em 0;
				overflow: auto;
				min-width: 100%;
				width: 0;
				white-space: pre-wrap;

				.qr--scope {
					display: grid;
					grid-template-columns: 0fr 1fr 1fr;
					column-gap: 0em;
					.qr--title {
						grid-column: 1 / 4;
						font-weight: bold;
						font-family: var(--mainFontFamily);
						background-color: var(--black50a);
						padding: 0.25em;
						margin-top: 0.5em;
					}
					.qr--var, .qr--macro, .qr--pipe {
						display: contents;
						&:nth-child(2n + 1) {
							.qr--key, .qr--val {
								background-color: rgb(from var(--SmartThemeEmColor) r g b / 0.25);
							}
							.qr--val {
								&:nth-child(2n) {
									background-color: rgb(from var(--SmartThemeEmColor) r g b / 0.125);
								}
								&:hover {
									background-color: rgb(from var(--SmartThemeEmColor) r g b / 0.5);
								}
							}
						}
						&:nth-child(2n) {
							.qr--val {
								&:nth-child(2n) {
									background-color: rgb(from var(--SmartThemeEmColor) r g b / 0.0625);
								}
								&:hover {
									background-color: rgb(from var(--SmartThemeEmColor) r g b / 0.5);
								}
							}
						}
						&.qr--isHidden {
							.qr--key, .qr--val {
								opacity: 0.5;
							}
						}
						.qr--val {
							grid-column: 2 / 4;
							&.qr--singleCol {
								grid-column: unset;
							}
							&.qr--simple {
								&:before, &:after {
									content: '"';
									color: var(--SmartThemeQuoteColor);
								}
							}
							&.qr--unresolved {
								&:after {
									content: '-UNRESOLVED-';
									font-style: italic;
									color: var(--SmartThemeQuoteColor);
								}
							}
						}
					}
					.qr--key {
						margin-left: 0.5em;
						padding-right: 1em;
						&:after { content: ": "; }
					}
					.qr--pipe, .qr--macro {
						> .qr--key {
							&:before { content: "{{"; }
							&:after { content: "}}: "; }
						}
					}
					.qr--scope {
						display: contents;
						.qr--pipe {
							.qr--key, .qr--val {
								opacity: 0.5;
							}
						}
					}
				}

				.qr--stack {
                    display: grid;
                    grid-template-columns: 1fr 0fr;
					.qr--title {
						grid-column: 1 / 3;
						font-weight: bold;
						font-family: var(--mainFontFamily);
						background-color: var(--black50a);
						padding: 0.25em;
						margin-top: 1em;
					}
					.qr--item {
                        display: contents;
						&:nth-child(2n + 1) {
                            .qr--name, .qr--source {
                                background-color: rgb(from var(--SmartThemeEmColor) r g b / 0.25);
                            }
						}
                        .qr--name {
                            margin-left: 0.5em;
                        }
                        .qr--source {
                            opacity: 0.5;
                            text-align: right;
                            white-space: nowrap;
                        }
					}
				}
            }
        }
    }
}

@keyframes qr--progressPulse {

    0%,
    100% {
        background-color: var(--progColor);
    }

    50% {
        background-color: var(--progFlashColor);
    }
}

@keyframes qr--debugPulse {
    0%,
    100% {
        border-color: rgb(81, 163, 81);
    }

    50% {
        border-color: rgb(146, 190, 252);
    }
}

.popup.qr--hide {
	opacity: 0 !important;
	&::backdrop {
		opacity: 0 !important;
	}
}

.popup.qr--hide::backdrop {
    opacity: 0 !important;
}



.popup:has(.qr--transferModal) {
	.popup-button-ok {
		&:after {
			content: 'Transfer';
			height: 0;
			overflow: hidden;
			font-weight: bold;
		}
		display: flex;
		align-items: center;
		flex-direction: column;
		white-space: pre;
		font-weight: normal;
		box-shadow: 0 0 0;
		transition: 200ms;
	}
	.qr--copy {
		&:after {
			content: 'Copy';
			height: 0;
			overflow: hidden;
			font-weight: bold;
		}
		display: flex;
		align-items: center;
		flex-direction: column;
		white-space: pre;
		font-weight: normal;
		box-shadow: 0 0 0;
		transition: 200ms;
	}
	&:has(.qr--transferSelect:focus) {
		.popup-button-ok {
			font-weight: bold;
			box-shadow: 0 0 10px;
		}
		&.qr--isCopy {
			.popup-button-ok {
				font-weight: normal;
				box-shadow: 0 0 0;
			}
			.qr--copy {
				font-weight: bold;
				box-shadow: 0 0 10px;
			}
		}
	}
}

